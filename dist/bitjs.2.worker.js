!function(e){var t={};function r(s){if(t[s])return t[s].exports;var i=t[s]={i:s,l:!1,exports:{}};return e[s].call(i.exports,i,i.exports,r),i.l=!0,i.exports}r.m=e,r.c=t,r.d=function(e,t,s){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(s,i,function(t){return e[t]}.bind(null,i));return s},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t);const s=[0,1,3,7,15,31,63,127,255];var i=class{constructor(e,t,r,s){if(!(e instanceof ArrayBuffer))throw"Error! BitArray constructed with an invalid ArrayBuffer object";const i=r||0,n=s||e.byteLength;this.bytes=new Uint8Array(e,i,n),this.bytePtr=0,this.bitPtr=0,this.bitsRead_=0,this.peekBits=t?this.peekBits_rtl:this.peekBits_ltr}getNumBitsRead(){return this.bitsRead_}getNumBitsLeft(){const e=8-this.bitPtr;return 8*(this.bytes.byteLength-this.bytePtr-1)+e}peekBits_ltr(e,t){const r=parseInt(e,10);let i=r;if(e!==i||i<=0)return 0;const n=t||!1;let o=this.bytes,a=this.bytePtr,h=this.bitPtr,l=0,u=0;for(;i>0&&!(a>=o.length);){const e=8-h;if(!(i>=e)){const e=s[i]<<h;l|=(o[a]&e)>>h<<u,h+=i;break}{const t=s[e]<<h;l|=(o[a]&t)>>h<<u,a++,h=0,u+=e,i-=e}}return n&&(this.bitPtr=h,this.bytePtr=a,this.bitsRead_+=r),l}peekBits_rtl(e,t){const r=parseInt(e,10);let i=r;if(e!==i||i<=0)return 0;const n=t||!1;let o=this.bytes,a=this.bytePtr,h=this.bitPtr,l=0;for(;i>0&&!(a>=o.length);){const e=8-h;if(!(i>=e)){l<<=i;const e=8-i-h;l|=(o[a]&s[i]<<e)>>e,h+=i;break}l<<=e,l|=s[e]&o[a],a++,h=0,i-=e}return n&&(this.bitPtr=h,this.bytePtr=a,this.bitsRead_+=r),l}getBits(){return((255&this.bytes[this.bytePtr])<<16)+((255&this.bytes[this.bytePtr+1])<<8)+(255&this.bytes[this.bytePtr+2])>>>8-this.bitPtr&65535}readBits(e){return this.peekBits(e,!0)}peekBytes(e,t){const r=parseInt(e,10);if(e!==r||r<0)throw"Error!  Called peekBytes() with a non-positive integer: "+e;if(0===r)return new Uint8Array;for(;0!=this.bitPtr;)this.readBits(1);if(r>this.getNumBitsLeft()/8)throw"Error!  Overflowed the bit stream! n="+r+", bytePtr="+this.bytePtr+", bytes.length="+this.bytes.length+", bitPtr="+this.bitPtr;const s=t||!1,i=new Uint8Array(r);let n=this.bytes,o=this.bytePtr,a=r;for(;a>0;){const e=n.length-o,t=Math.min(a,e);if(i.set(n.subarray(o,o+t),r-a),o+=t,o>=n.length)break;a-=t}return s&&(this.bytePtr+=r,this.bitsRead_+=8*r),i}readBytes(e){return this.peekBytes(e,!0)}};class n{constructor(e,t,r){if(!(e instanceof ArrayBuffer))throw"Error! BitArray constructed with an invalid ArrayBuffer object";const s=t||0,i=r||e.byteLength;this.bytes=new Uint8Array(e,s,i),this.pages_=[],this.ptr=0,this.bytesRead_=0}getNumBytesRead(){return this.bytesRead_}getNumBytesLeft(){const e=this.bytes.byteLength-this.ptr;return this.pages_.reduce((e,t)=>e+t.length,e)}movePointer_(e){for(this.ptr+=e,this.bytesRead_+=e;this.ptr>=this.bytes.length&&this.pages_.length>0;)this.ptr-=this.bytes.length,this.bytes=this.pages_.shift()}peekNumber(e){const t=parseInt(e,10);if(e!==t||t<0)throw"Error!  Called peekNumber() with a non-positive integer";if(0===t)return 0;if(e>4)throw"Error!  Called peekNumber("+e+") but this method can only reliably read numbers up to 4 bytes long";if(this.getNumBytesLeft()<t)throw"Error!  Overflowed the byte stream while peekNumber()! n="+t+", ptr="+this.ptr+", bytes.length="+this.getNumBytesLeft();let r=0,s=this.bytes,i=0,n=this.ptr;for(let e=0;e<t;++e)r|=s[n++]<<8*e,n>=s.length&&(s=this.pages_[i++],n=0);return r}readNumber(e){const t=this.peekNumber(e);return this.movePointer_(e),t}peekSignedNumber(e){let t=this.peekNumber(e);const r=Math.pow(2,8*e-1);return t>=r&&(t-=2*r),t}readSignedNumber(e){const t=this.peekSignedNumber(e);return this.movePointer_(e),t}peekBytes(e,t){const r=parseInt(e,10);if(e!==r||r<0)throw"Error!  Called peekBytes() with a non-positive integer";if(0===r)return new Uint8Array;if(r>this.getNumBytesLeft())throw"Error!  Overflowed the byte stream during peekBytes! n="+r+", ptr="+this.ptr+", bytes.length="+this.getNumBytesLeft();const s=new Uint8Array(r);let i=this.bytes,n=this.ptr,o=r,a=0;for(;o>0;){const e=i.length-n,t=Math.min(o,e);s.set(i.subarray(n,n+t),r-o),n+=t,n>=i.length&&(i=this.pages_[a++],n=0),o-=t}return t&&this.movePointer_(r),s}readBytes(e){return this.peekBytes(e,!0)}peekString(e){const t=parseInt(e,10);if(e!==t||t<0)throw"Error!  Called peekString() with a non-positive integer";if(0===t)return"";if(t>this.getNumBytesLeft())throw"Error!  Overflowed the byte stream while peekString()! n="+t+", ptr="+this.ptr+", bytes.length="+this.getNumBytesLeft();let r=new Array(t),s=this.bytes,i=0,n=this.ptr;for(let e=0;e<t;++e)r[e]=String.fromCharCode(s[n++]),n>=s.length&&(s=this.pages_[i++],n=0);return r.join("")}readString(e){const t=this.peekString(e);return this.movePointer_(e),t}push(e){if(!(e instanceof ArrayBuffer))throw"Error! ByteStream.push() called with an invalid ArrayBuffer object";this.pages_.push(new Uint8Array(e)),this.movePointer_(0)}tee(){const e=new n(this.bytes.buffer);return e.bytes=this.bytes,e.ptr=this.ptr,e.pages_=this.pages_.slice(),e.bytesRead_=this.bytesRead_,e}}var o=n;var a=class{constructor(e){if("number"!=typeof e||e<=0)throw"Error! ByteBuffer initialized with '"+e+"'";this.data=new Uint8Array(e),this.ptr=0}insertByte(e){this.data[this.ptr++]=e}insertBytes(e){this.data.set(e,this.ptr),this.ptr+=e.length}writeNumber(e,t){if(t<1||!t)throw"Trying to write into too few bytes: "+t;if(e<0)throw"Trying to write a negative number ("+e+") as an unsigned number to an ArrayBuffer";if(e>Math.pow(2,8*t)-1)throw"Trying to write "+e+" into only "+t+" bytes";const r=[];for(;t-- >0;){const t=255&e;r.push(t),e>>=8}this.insertBytes(r)}writeSignedNumber(e,t){if(t<1)throw"Trying to write into too few bytes: "+t;const r=Math.pow(2,8*t-1);if(e>=r||e<-r)throw"Trying to write "+e+" into only "+t+" bytes";const s=[];for(;t-- >0;){const t=255&e;s.push(t),e>>=8}this.insertBytes(s)}writeASCIIString(e){for(let t=0;t<e.length;++t){const r=e.charCodeAt(t);if(r<0||r>255)throw"Trying to write a non-ASCII string!";this.insertByte(r)}}};const h=0,l=1,u=2,f=3;let d=h,c=null,m=null,b=!1,y="",p=0,g=0,N=0,B=0,w=0;const S=function(e){postMessage({type:"info",msg:e})},v=function(e){postMessage({type:"error",msg:e})},P=function(){postMessage({type:"progress",currentFilename:y,currentFileNumber:p,currentBytesUnarchivedInFile:g,currentBytesUnarchived:N,totalUncompressedBytesInArchive:B,totalFilesInArchive:w,totalCompressedBytesRead:c.getNumBytesRead()})},k=[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768];class L{constructor(e){if(typeof e!=typeof{}||!e.readNumber||"function"!=typeof e.readNumber)return null;e.readNumber(4),this.version=e.readNumber(2),this.generalPurpose=e.readNumber(2),this.compressionMethod=e.readNumber(2),this.lastModFileTime=e.readNumber(2),this.lastModFileDate=e.readNumber(2),this.crc32=e.readNumber(4),this.compressedSize=e.readNumber(4),this.uncompressedSize=e.readNumber(4),this.fileNameLength=e.readNumber(2),this.extraFieldLength=e.readNumber(2),this.filename=null,this.fileNameLength>0&&(this.filename=e.readString(this.fileNameLength)),this.extraField=null,this.extraFieldLength>0&&(this.extraField=e.readString(this.extraFieldLength)),this.fileData=null,this.compressedSize>0&&(this.fileData=new Uint8Array(e.readBytes(this.compressedSize))),0!=(this.generalPurpose&k[3])&&(this.crc32=e.readNumber(4),this.compressedSize=e.readNumber(4),this.uncompressedSize=e.readNumber(4)),b&&(S("Zip Local File Header:"),S(" version="+this.version),S(" general purpose="+this.generalPurpose),S(" compression method="+this.compressionMethod),S(" last mod file time="+this.lastModFileTime),S(" last mod file date="+this.lastModFileDate),S(" crc32="+this.crc32),S(" compressed size="+this.compressedSize),S(" uncompressed size="+this.uncompressedSize),S(" file name length="+this.fileNameLength),S(" extra field length="+this.extraFieldLength),S(" filename = '"+this.filename+"'"))}unzip(){0==this.compressionMethod?(b&&S("ZIP v"+this.version+", store only: "+this.filename+" ("+this.compressedSize+" bytes)"),g=this.compressedSize,N+=this.compressedSize):8==this.compressionMethod?(b&&S("ZIP v2.0, DEFLATE: "+this.filename+" ("+this.compressedSize+" bytes)"),this.fileData=function(e,t){const r=new i(e.buffer,!1,e.byteOffset,e.byteLength),s=new a(t);let n=0,o=0;do{o=r.readBits(1);let e=r.readBits(2);if(n=0,0==e){for(;0!=r.bitPtr;)r.readBits(1);const e=r.readBits(16);r.readBits(16);e>0&&s.insertBytes(r.readBytes(e)),n=e}else if(1==e)n=D(r,M(),C(),s);else{if(2!=e)return v("Error! Encountered deflate block of type 3"),null;{const e=r.readBits(5)+257,t=r.readBits(5)+1,i=r.readBits(4)+4,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(let e=0;e<i;++e)o[O[e]]=r.readBits(3);const a=_(o),h=[];let l=0;for(;h.length<e+t;){const e=z(r,a);if(e<=15)h.push(e),l=e;else if(16==e){let e=r.readBits(2)+3;for(;e--;)h.push(l)}else if(17==e){let e=r.readBits(3)+3;for(;e--;)h.push(0)}else if(18==e){let e=r.readBits(7)+11;for(;e--;)h.push(0)}}const u=h.splice(e,t),f=_(h),d=_(u);n=D(r,f,d,s)}}g+=n,N+=n,P()}while(1!=o);return s.data}(this.fileData,this.uncompressedSize)):(v("UNSUPPORTED VERSION/FORMAT: ZIP v"+this.version+", compression method="+this.compressionMethod+": "+this.filename+" ("+this.compressedSize+" bytes)"),this.fileData=null)}}function _(e){if(typeof e!=typeof[]||e.length<1)return v("Error! getHuffmanCodes() called with an invalid array"),null;const t=e.length,r=[];let s=1;for(let i=0;i<t;++i){const t=e[i];if("number"!=typeof t||t<0)return v("bitLengths contained an invalid number in getHuffmanCodes(): "+t+" of type "+typeof t),null;null==r[t]&&(r[t]=0),t>0&&r[t]++,t>s&&(s=t)}const i=[];let n=0;for(let e=1;e<=s;++e){const t=e-1;null==r[t]&&(r[t]=0),n=n+r[e-1]<<1,i[e]=n}const o={};let a=0;for(let r=0;r<t;++r){const t=e[r];0!=t&&(o[i[t]]={length:t,symbol:r},a++,i[t]++)}return o.maxLength=a,o}let F=null,A=null;function M(){if(!F){const e=new Array(288);for(let t=0;t<=143;++t)e[t]=8;for(let t=144;t<=255;++t)e[t]=9;for(let t=256;t<=279;++t)e[t]=7;for(let t=280;t<=287;++t)e[t]=8;F=_(e)}return F}function C(){if(!A){const e=new Array(32);for(let t=0;t<32;++t)e[t]=5;A=_(e)}return A}function z(e,t){let r=0,s=0;for(;;){if(r=r<<1|e.readBits(1),++s,t.hasOwnProperty(r)&&t[r].length==s)break;if(s>t.maxLength){v("Bit stream out of sync, didn't find a Huffman Code, length was "+s+" and table only max code length of "+t.maxLength);break}}return t[r].symbol}const O=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],E=[[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[0,10],[1,11],[1,13],[1,15],[1,17],[2,19],[2,23],[2,27],[2,31],[3,35],[3,43],[3,51],[3,59],[4,67],[4,83],[4,99],[4,115],[5,131],[5,163],[5,195],[5,227],[0,258]],x=[[0,1],[0,2],[0,3],[0,4],[1,5],[1,7],[2,9],[2,13],[3,17],[3,25],[4,33],[4,49],[5,65],[5,97],[6,129],[6,193],[7,257],[7,385],[8,513],[8,769],[9,1025],[9,1537],[10,2049],[10,3073],[11,4097],[11,6145],[12,8193],[12,12289],[13,16385],[13,24577]];function D(e,t,r,s){let i=0;for(;;){const n=z(e,t);if(n<256)s.insertByte(n),i++;else{if(256==n)break;{const t=E[n-257];let o=t[1]+e.readBits(t[0]);const a=x[z(e,r)];let h=a[1]+e.readBits(a[0]),l=s.ptr-h;if(i+=o,o>h){const e=s.data;for(;o--;)s.insertByte(e[l++])}else s.insertBytes(s.data.subarray(l,l+o))}}}return i}onmessage=function(e){const t=e.data.file||e.data.bytes;if(b=!!e.data.logToConsole,c?c.push(t):c=new o(t),d===h&&(y="",p=0,g=0,N=0,B=0,w=0,N=0,m=[],postMessage({type:"start"}),d=l,P()),d===l||d===u)try{!function(){let e=c.tee();for(;67324752==e.peekNumber(4);){const t=new L(e);t&&t.uncompressedSize>0&&t.fileData&&(c=e.tee(),m.push(t),B+=t.uncompressedSize,y=t.filename,p=m.length-1,g=0,t.unzip(),null!=t.fileData&&(postMessage({type:"extract",unarchivedFile:t}),P()))}if(w=m.length,134630224==e.peekNumber(4)){b&&S(" Found an Archive Extra Data Signature"),e.readNumber(4);const t=e.readNumber(4);e.readString(t)}if(33639248==c.peekNumber(4))for(b&&S(" Found a Central File Header");33639248==e.peekNumber(4);){e.readNumber(4);const t={versionMadeBy:e.readNumber(2),versionNeededToExtract:e.readNumber(2),generalPurposeBitFlag:e.readNumber(2),compressionMethod:e.readNumber(2),lastModFileTime:e.readNumber(2),lastModFileDate:e.readNumber(2),crc32:e.readNumber(4),compressedSize:e.readNumber(4),uncompressedSize:e.readNumber(4),fileNameLength:e.readNumber(2),extraFieldLength:e.readNumber(2),fileCommentLength:e.readNumber(2),diskNumberStart:e.readNumber(2),internalFileAttributes:e.readNumber(2),externalFileAttributes:e.readNumber(4),relativeOffset:e.readNumber(4)};if(t.fileName=e.readString(t.fileNameLength),t.extraField=e.readString(t.extraFieldLength),t.fileComment=e.readString(t.fileCommentLength),b){console.log("Central Directory File Header:");for(const e in t)console.log(`  ${e} = ${t[e]}`)}}if(84233040==e.peekNumber(4)){b&&S(" Found a Digital Signature"),e.readNumber(4);const t=e.readNumber(2);e.readString(t)}let t={};if(101010256==e.peekNumber(4)){e.readNumber(4);const r={numberOfThisDisk:e.readNumber(2),diskWhereCentralDirectoryStarts:e.readNumber(2),numberOfCentralDirectoryRecordsOnThisDisk:e.readNumber(2),totalNumberOfCentralDirectoryRecords:e.readNumber(2),sizeOfCentralDirectory:e.readNumber(4),offsetOfStartOfCentralDirectory:e.readNumber(4),commentLength:e.readNumber(2)};if(r.comment=e.readString(r.commentLength),b){console.log("End of Central Dir Signature:");for(const e in r)console.log(`  ${e} = ${r[e]}`)}t.comment=r.comment}P(),c=e.tee(),d=f,postMessage({type:"finish",metadata:t})}()}catch(e){if("string"!=typeof e||!e.startsWith("Error!  Overflowed"))throw console.error("Found an error while unzipping"),console.dir(e),e;d=u}}}]);
//# sourceMappingURL=bitjs.2.worker.js.map