{"version":3,"sources":["webpack://bitjs/webpack/universalModuleDefinition","webpack://bitjs/webpack/bootstrap","webpack://bitjs/./src/archive/archive.js","webpack://bitjs/./src/file/sniffer.js","webpack://bitjs/./src/archive/unrar.js","webpack://bitjs/./src/archive/untar.js","webpack://bitjs/./src/archive/unzip.js","webpack://bitjs/./src/archive/unzip.js?2e8a","webpack://bitjs/./src/archive/unrar.js?990c","webpack://bitjs/./src/archive/untar.js?7e21","webpack://bitjs/./src/io/bitstream.js","webpack://bitjs/./src/io/bytebuffer.js","webpack://bitjs/./src/io/bytestream.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","UnarchiveEvent","type","this","UnarchiveEventType","START","PROGRESS","EXTRACT","FINISH","INFO","ERROR","UnarchiveInfoEvent","msg","super","UnarchiveErrorEvent","UnarchiveStartEvent","UnarchiveFinishEvent","metadata","UnarchiveProgressEvent","currentFilename","currentFileNumber","currentBytesUnarchivedInFile","currentBytesUnarchived","totalUncompressedBytesInArchive","totalFilesInArchive","totalCompressedBytesRead","UnarchiveExtractEvent","unarchivedFile","Unarchiver","arrayBuffer","workerRootPath","ab","listeners_","worker_","listener","indexOf","push","index","splice","obj","values","includes","Array","evt","createUnarchiveEvent_","forEach","terminate","console","log","me","worker","getWorker","onerror","e","message","onmessage","data","handleWorkerEvent_","postMessage","file","logToConsole","bytes","Unzipper","Worker","Unrarrer","Untarrer","getUnarchiver","byteLength","unarchiver","mimetype","fileSignatures","Node","children","mimeType","undefined","maxDepth","signature","curNode","depth","byte","keys","length","findMimeType","arr","Uint8Array","subarray","BITMASK","BitStream","rtl","opt_offset","opt_length","ArrayBuffer","offset","bytePtr","bitPtr","bitsRead_","peekBits","peekBits_rtl","peekBits_ltr","bitsLeftInByte","opt_movePointers","NUM","parseInt","num","movePointers","result","bitsIn","numBitsLeftInThisByte","mask","numBits","readBits","getNumBitsLeft","ptr","bytesLeftToCopy","bytesLeftInStream","sourceLength","Math","min","set","peekBytes","ByteBuffer","numBytes","b","pow","eightBits","insertBytes","HALF","str","curByte","charCodeAt","insertByte","ByteStream","pages_","bytesRead_","bytesInCurrentPage","reduce","acc","shift","getNumBytesLeft","curPage","pageIndex","peekNumber","movePointer_","peekSignedNumber","bytesLeftInPage","String","fromCharCode","join","strToReturn","peekString","clone","buffer","slice"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAe,MAAID,IAEnBD,EAAY,MAAIC,IARlB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,gCClFrD,qgBAkBO,MAAMC,EAIX,YAAYC,GAKVC,KAAKD,KAAOA,GAOT,MAAME,EAAqB,CAChCC,MAAO,QACPC,SAAU,WACVC,QAAS,UACTC,OAAQ,SACRC,KAAM,OACNC,MAAO,SAMF,MAAMC,UAA2BV,EAItC,YAAYW,GACVC,MAAMT,EAAmBK,MAMzBN,KAAKS,IAAMA,GAOR,MAAME,UAA4Bb,EAIvC,YAAYW,GACVC,MAAMT,EAAmBM,OAMzBP,KAAKS,IAAMA,GAOR,MAAMG,UAA4Bd,EACvC,cACEY,MAAMT,EAAmBC,QAOtB,MAAMW,UAA6Bf,EAIxC,YAAYgB,EAAW,IACrBJ,MAAMT,EAAmBI,QACzBL,KAAKc,SAAWA,GAOb,MAAMC,UAA+BjB,EAU1C,YACEkB,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEAZ,MAAMT,EAAmBE,UAEzBH,KAAKgB,gBAAkBA,EACvBhB,KAAKiB,kBAAoBA,EACzBjB,KAAKkB,6BAA+BA,EACpClB,KAAKqB,oBAAsBA,EAC3BrB,KAAKmB,uBAAyBA,EAC9BnB,KAAKoB,gCAAkCA,EACvCpB,KAAKsB,yBAA2BA,GAO7B,MAAMC,UAA8BzB,EAIzC,YAAY0B,GACVd,MAAMT,EAAmBG,SAKzBJ,KAAKwB,eAAiBA,GAkBnB,MAAMC,EAKX,YAAYC,EAAaC,GAMvB3B,KAAK4B,GAAKF,EAOV1B,KAAK2B,eAAiBA,EAMtB3B,KAAK6B,WAAa,GAClB,IAAK,IAAI9B,KAAQE,EACfD,KAAK6B,WAAW5B,EAAmBF,IAAS,GAQ9CC,KAAK8B,QAAU,KAQjB,YACE,KAAM,6DASR,iBAAiB/B,EAAMgC,GACjBhC,KAAQC,KAAK6B,aACiC,GAA5C7B,KAAK6B,WAAW9B,GAAMiC,QAAQD,IAChC/B,KAAK6B,WAAW9B,GAAMkC,KAAKF,GAWjC,oBAAoBhC,EAAMgC,GACxB,GAAIhC,KAAQC,KAAK6B,WAAY,CAC3B,MAAMK,EAAQlC,KAAK6B,WAAW9B,GAAMiC,QAAQD,IAC9B,GAAVG,GACFlC,KAAK6B,WAAW9B,GAAMoC,OAAOD,EAAO,IAW1C,sBAAsBE,GACpB,OAAQA,EAAIrC,MACV,KAAKE,EAAmBC,MACtB,OAAO,IAAIU,EACb,KAAKX,EAAmBE,SACtB,OAAO,IAAIY,EACTqB,EAAIpB,gBACJoB,EAAInB,kBACJmB,EAAIlB,6BACJkB,EAAIjB,uBACJiB,EAAIhB,gCACJgB,EAAIf,oBACJe,EAAId,0BAER,KAAKrB,EAAmBG,QACtB,OAAO,IAAImB,EAAsBa,EAAIZ,gBACvC,KAAKvB,EAAmBI,OACtB,OAAO,IAAIQ,EAAqBuB,EAAItB,UACtC,KAAKb,EAAmBK,KACtB,OAAO,IAAIE,EAAmB4B,EAAI3B,KACpC,KAAKR,EAAmBM,MACtB,OAAO,IAAII,EAAoByB,EAAI3B,MAUzC,mBAAmB2B,GACjB,MAAMrC,EAAOqC,EAAIrC,KACjB,GACEA,GACAvB,OAAO6D,OAAOpC,GAAoBqC,SAASvC,IAC3CC,KAAK6B,WAAWO,EAAIrC,gBAAiBwC,MACrC,CACA,MAAMC,EAAMxC,KAAKyC,sBAAsBL,GACvCpC,KAAK6B,WAAWW,EAAIzC,MAAM2C,SAAQ,SAAUX,GAC1CA,EAASS,MAEPA,EAAIzC,MAAQE,EAAmBI,QACjCL,KAAK8B,QAAQa,iBAGfC,QAAQC,IAAI,wCAAwCT,GAOxD,QACE,MAAMU,EAAK9C,KACL+C,EAAS/C,KAAKgD,YACpB,GAAID,EAAQ,CACV/C,KAAK8B,QAAUiB,EAEf/C,KAAK8B,QAAQmB,QAAU,SAAUC,GAE/B,MADAN,QAAQC,IAAI,2BAA6BK,EAAEC,SACrCD,GAGRlD,KAAK8B,QAAQsB,UAAY,SAAUF,GACZ,iBAAVA,EAAEG,KAEXT,QAAQC,IAAIK,EAAEG,MAEdP,EAAGQ,mBAAmBJ,EAAEG,OAI5B,MAAMzB,EAAK5B,KAAK4B,GAChB5B,KAAK8B,QAAQyB,YAAY,CACvBC,KAAM5B,EACN6B,cAAc,IAEhBzD,KAAK4B,GAAK,MAQd,OAAOA,GACD5B,KAAK8B,SACP9B,KAAK8B,QAAQyB,YAAY,CAAEG,MAAO9B,IAOtC,OACM5B,KAAK8B,SACP9B,KAAK8B,QAAQa,aAQZ,MAAMgB,UAAiBlC,EAC5B,YAAYC,EAAaC,EAAiB,MACxCjB,MAAMgB,EAAaC,GAGrB,YACE,OAAI3B,KAAK2B,eACA,IAAIiC,OAAO5D,KAAK2B,eAAiB,IAAM,KAEzC,IAAIiC,OAAO,IAOf,MAAMC,UAAiBpC,EAC5B,YAAYC,EAAaC,EAAiB,MACxCjB,MAAMgB,EAAaC,GAGrB,YACE,OAAI3B,KAAK2B,eACA,IAAIiC,OAAO5D,KAAK2B,eAAiB,IAAM,KAEzC,IAAIiC,OAAO,IASf,MAAME,UAAiBrC,EAC5B,YAAYC,EAAaC,EAAiB,MACxCjB,MAAMgB,EAAaC,GAGrB,YACE,OAAI3B,KAAK2B,eACA,IAAIiC,OAAO5D,KAAK2B,eAAiB,IAAM,KAEzC,IAAIiC,OAAO,IAWf,SAASG,EAAcnC,EAAID,EAAiB,MACjD,GAAIC,EAAGoC,WAAa,GAClB,OAAO,KAGT,IAAIC,EAAa,KAYjB,OAREA,EAFe,iCADA,YAAarC,GAGf,IAAIiC,EAASjC,EAAID,GACR,oBAAbuC,SAEI,IAAIP,EAAS/B,EAAID,GAGjB,IAAImC,EAASlC,EAAID,GAEzBsC,K,wDCvaT,kCAYA,MAAME,EAAiB,CAErB,kBAAmB,CAAC,CAAC,GAAM,GAAM,GAAM,GAAM,KAE7C,8BAA+B,CAAC,CAAC,GAAM,IAAM,IAAM,IAAM,GAAM,KAC/D,sBAAuB,CAAC,CAAC,GAAM,GAAM,MACrC,+BAAgC,CAAC,CAAC,GAAM,GAAM,IAAM,GAAM,GAAM,IAChE,kBAAmB,CACjB,CAAC,GAAM,GAAM,EAAM,GACnB,CAAC,GAAM,GAAM,EAAM,GACnB,CAAC,GAAM,GAAM,EAAM,IAGrB,YAAa,CAAC,CAAC,GAAM,KACrB,YAAa,CAAC,CAAC,GAAM,GAAM,GAAM,KACjC,aAAc,CAAC,CAAC,IAAM,IAAM,MAC5B,YAAa,CAAC,CAAC,IAAM,GAAM,GAAM,GAAM,GAAM,GAAM,GAAM,KACzD,aAAc,CACZ,CAAC,GAAM,GAAM,GAAM,GAAM,KAAM,KAAM,KAAM,KAAM,GAAM,GAAM,GAAM,MAIvE,MAAMC,EAEJ,YAAYrF,GACViB,KAAKjB,MAAQA,EACbiB,KAAKqE,SAAW,GAChBrE,KAAKsE,cAAWC,GAKpB,MAAMnH,EAAO,IAAIgH,EACjB,IAAII,EAAW,EAGf,IAAK,MAAMF,KAAYH,EACrB,IAAK,MAAMM,KAAaN,EAAeG,GAAW,CAChD,IAAII,EAAUtH,EACVuH,EAAQ,EACZ,IAAK,MAAMC,KAAQH,EAAW,CAC5B,QAA+BF,IAA3BG,EAAQL,SAASO,GAAqB,CACxC,GACW,OAATA,IACCF,EAAQL,SAAS,OAClB7F,OAAOqG,KAAKH,EAAQL,UAAUS,OAAS,EAEvC,KAAM,6EACD,GAAa,OAATF,GAAiBF,EAAQL,SAAS,MAC3C,KAAM,4EAERK,EAAQL,SAASO,GAAQ,IAAIR,EAAKQ,GAEpCD,IACAD,EAAUA,EAAQL,SAASO,GAO7B,GAJIJ,EAAWG,IACbH,EAAWG,GAGTD,EAAQJ,SACV,KAAM,8BAA8BI,EAAQJ,0BAA0BA,IACjE,GAAI9F,OAAOqG,KAAKH,EAAQL,UAAUS,OAAS,EAChD,MAASR,EAAH,8DAERI,EAAQJ,SAAWA,EAQhB,SAASS,EAAanD,GAC3B,MAAM+C,EAAQ/C,EAAGoC,WAAaQ,EAAW5C,EAAGoC,WAAaQ,EACnDQ,EAAM,IAAIC,WAAWrD,GAAIsD,SAAS,EAAGP,GAC3C,IAAID,EAAUtH,EACd,IAAK,MAAMwH,KAAQI,EAEjB,GAAIN,EAAQL,SAAS,MACnBK,EAAUA,EAAQL,SAAS,UAD7B,CAIA,QAA+BE,IAA3BG,EAAQL,SAASO,GAAqB,OAE1C,GADAF,EAAUA,EAAQL,SAASO,GACvBF,EAAQJ,SAAU,OAAOI,EAAQJ,Y,gBClGzC/G,EAAOD,QAAU,IAA0B,qB,gBCA3CC,EAAOD,QAAU,IAA0B,qB,gBCA3CC,EAAOD,QAAU,IAA0B,qB,gBCA3CC,EAAOD,QAAU,IAA0B,qB,gBCA3CC,EAAOD,QAAU,IAA0B,qB,gBCA3CC,EAAOD,QAAU,IAA0B,qB,k3BCY3C,MAAM6H,EAAU,CAAC,EAAG,EAAM,EAAM,EAAM,GAAM,GAAM,GAAM,IAAM,KAQvD,MAAMC,EAQX,YAAYxD,EAAIyD,EAAKC,EAAYC,GAC/B,KAAM3D,aAAc4D,aAClB,KAAM,iEAGR,MAAMC,EAASH,GAAc,EACvBR,EAASS,GAAc3D,EAAGoC,WAOhChE,KAAK0D,MAAQ,IAAIuB,WAAWrD,EAAI6D,EAAQX,GAOxC9E,KAAK0F,QAAU,EAOf1F,KAAK2F,OAAS,EAOd3F,KAAK4F,UAAY,EAEjB5F,KAAK6F,SAAWR,EAAMrF,KAAK8F,aAAe9F,KAAK+F,aAMjD,iBACE,OAAO/F,KAAK4F,UAMd,iBACE,MAAMI,EAAiB,EAAIhG,KAAK2F,OAChC,OAAoD,GAA5C3F,KAAK0D,MAAMM,WAAahE,KAAK0F,QAAU,GAASM,EAa1D,aAAazG,EAAG0G,GACd,MAAMC,EAAMC,SAAS5G,EAAG,IACxB,IAAI6G,EAAMF,EACV,GAAI3G,IAAM6G,GAAOA,GAAO,EACtB,OAAO,EAGT,MAAMC,EAAeJ,IAAoB,EACzC,IAAIvC,EAAQ1D,KAAK0D,MACbgC,EAAU1F,KAAK0F,QACfC,EAAS3F,KAAK2F,OACdW,EAAS,EACTC,EAAS,EAGb,KAAOH,EAAM,KAEPV,GAAWhC,EAAMoB,SAFP,CAMd,MAAM0B,EAAwB,EAAIb,EAClC,KAAIS,GAAOI,GAQJ,CACL,MAAMC,EAAOtB,EAAQiB,IAAQT,EAC7BW,IAAY5C,EAAMgC,GAAWe,IAASd,GAAWY,EAEjDZ,GAAUS,EACV,MAbgC,CAChC,MAAMK,EAAOtB,EAAQqB,IAA0Bb,EAC/CW,IAAY5C,EAAMgC,GAAWe,IAASd,GAAWY,EAEjDb,IACAC,EAAS,EACTY,GAAUC,EACVJ,GAAOI,GAgBX,OANIH,IACFrG,KAAK2F,OAASA,EACd3F,KAAK0F,QAAUA,EACf1F,KAAK4F,WAAaM,GAGbI,EAaT,aAAa/G,EAAG0G,GACd,MAAMC,EAAMC,SAAS5G,EAAG,IACxB,IAAI6G,EAAMF,EACV,GAAI3G,IAAM6G,GAAOA,GAAO,EACtB,OAAO,EAGT,MAAMC,EAAeJ,IAAoB,EACzC,IAAIvC,EAAQ1D,KAAK0D,MACbgC,EAAU1F,KAAK0F,QACfC,EAAS3F,KAAK2F,OACdW,EAAS,EAGb,KAAOF,EAAM,KAEPV,GAAWhC,EAAMoB,SAFP,CAMd,MAAM0B,EAAwB,EAAIb,EAClC,KAAIS,GAAOI,GAMJ,CACLF,IAAWF,EACX,MAAMM,EAAU,EAAIN,EAAMT,EAC1BW,IAAW5C,EAAMgC,GAAYP,EAAQiB,IAAQM,IAAaA,EAE1Df,GAAUS,EACV,MAXAE,IAAWE,EACXF,GAAUnB,EAAQqB,GAAyB9C,EAAMgC,GACjDA,IACAC,EAAS,EACTS,GAAOI,EAiBX,OANIH,IACFrG,KAAK2F,OAASA,EACd3F,KAAK0F,QAAUA,EACf1F,KAAK4F,WAAaM,GAGbI,EAST,UACE,QACiC,IAA3BtG,KAAK0D,MAAM1D,KAAK0F,WAAoB,MACL,IAA/B1F,KAAK0D,MAAM1D,KAAK0F,QAAU,KAAc,IACV,IAA/B1F,KAAK0D,MAAM1D,KAAK0F,QAAU,MAC1B,EAAI1F,KAAK2F,OACZ,MASJ,SAASpG,GACP,OAAOS,KAAK6F,SAAStG,GAAG,GAW1B,UAAUA,EAAG0G,GACX,MAAMG,EAAMD,SAAS5G,EAAG,IACxB,GAAIA,IAAM6G,GAAOA,EAAM,EACrB,KAAM,2DAA6D7G,EAC9D,GAAY,IAAR6G,EACT,OAAO,IAAInB,WAMb,KAAsB,GAAfjF,KAAK2F,QACV3F,KAAK2G,SAAS,GAIhB,GAAIP,EADiBpG,KAAK4G,iBAAmB,EAE3C,KACE,wCACAR,EACA,aACApG,KAAK0F,QACL,kBACA1F,KAAK0D,MAAMoB,OACX,YACA9E,KAAK2F,OAIT,MAAMU,EAAeJ,IAAoB,EACnCK,EAAS,IAAIrB,WAAWmB,GAC9B,IAAI1C,EAAQ1D,KAAK0D,MACbmD,EAAM7G,KAAK0F,QACXoB,EAAkBV,EACtB,KAAOU,EAAkB,GAAG,CAC1B,MAAMC,EAAoBrD,EAAMoB,OAAS+B,EACnCG,EAAeC,KAAKC,IAAIJ,EAAiBC,GAS/C,GAPAT,EAAOa,IACLzD,EAAMwB,SAAS2B,EAAKA,EAAMG,GAC1BZ,EAAMU,GAGRD,GAAOG,EAEHH,GAAOnD,EAAMoB,OACf,MAGFgC,GAAmBE,EAQrB,OALIX,IACFrG,KAAK0F,SAAWU,EAChBpG,KAAK4F,WAAmB,EAANQ,GAGbE,EAOT,UAAU/G,GACR,OAAOS,KAAKoH,UAAU7H,GAAG,ICxRtB,MAAM8H,EAIX,YAAYC,GACV,GAAuB,iBAAZA,GAAwBA,GAAY,EAC7C,KAAM,uCAAyCA,EAAW,IAE5DtH,KAAKqD,KAAO,IAAI4B,WAAWqC,GAC3BtH,KAAK6G,IAAM,EAMb,WAAWU,GAETvH,KAAKqD,KAAKrD,KAAK6G,OAASU,EAM1B,YAAY7D,GAEV1D,KAAKqD,KAAK8D,IAAIzD,EAAO1D,KAAK6G,KAC1B7G,KAAK6G,KAAOnD,EAAMoB,OASpB,YAAYsB,EAAKkB,GACf,GAAIA,EAAW,IAAMA,EACnB,KAAM,uCAAyCA,EAEjD,GAAIlB,EAAM,EACR,KACE,sCACAA,EACA,4CAGJ,GAAIA,EAAMa,KAAKO,IAAI,EAAc,EAAXF,GAAgB,EACpC,KAAM,mBAAqBlB,EAAM,cAAgBkB,EAAW,SAI9D,MAAM5D,EAAQ,GACd,KAAO4D,KAAa,GAAG,CACrB,MAAMG,EAAkB,IAANrB,EAClB1C,EAAMzB,KAAKwF,GACXrB,IAAQ,EAGVpG,KAAK0H,YAAYhE,GASnB,kBAAkB0C,EAAKkB,GACrB,GAAIA,EAAW,EACb,KAAM,uCAAyCA,EAGjD,MAAMK,EAAOV,KAAKO,IAAI,EAAc,EAAXF,EAAe,GACxC,GAAIlB,GAAOuB,GAAQvB,GAAOuB,EACxB,KAAM,mBAAqBvB,EAAM,cAAgBkB,EAAW,SAI9D,MAAM5D,EAAQ,GACd,KAAO4D,KAAa,GAAG,CACrB,MAAMG,EAAkB,IAANrB,EAClB1C,EAAMzB,KAAKwF,GACXrB,IAAQ,EAGVpG,KAAK0H,YAAYhE,GAMnB,iBAAiBkE,GACf,IAAK,IAAI9J,EAAI,EAAGA,EAAI8J,EAAI9C,SAAUhH,EAAG,CACnC,MAAM+J,EAAUD,EAAIE,WAAWhK,GAC/B,GAAI+J,EAAU,GAAKA,EAAU,IAC3B,KAAM,sCAER7H,KAAK+H,WAAWF,KC/Ff,MAAMG,EAMX,YAAYpG,EAAI0D,EAAYC,GAC1B,KAAM3D,aAAc4D,aAClB,KAAM,iEAGR,MAAMC,EAASH,GAAc,EACvBR,EAASS,GAAc3D,EAAGoC,WAOhChE,KAAK0D,MAAQ,IAAIuB,WAAWrD,EAAI6D,EAAQX,GAOxC9E,KAAKiI,OAAS,GAOdjI,KAAK6G,IAAM,EAOX7G,KAAKkI,WAAa,EAMpB,kBACE,OAAOlI,KAAKkI,WAMd,kBACE,MAAMC,EAAqBnI,KAAK0D,MAAMM,WAAahE,KAAK6G,IACxD,OAAO7G,KAAKiI,OAAOG,OACjB,CAACC,EAAKrD,IAAQqD,EAAMrD,EAAIF,OACxBqD,GAWJ,aAAa5I,GAGX,IAFAS,KAAK6G,KAAOtH,EACZS,KAAKkI,YAAc3I,EACZS,KAAK6G,KAAO7G,KAAK0D,MAAMoB,QAAU9E,KAAKiI,OAAOnD,OAAS,GAC3D9E,KAAK6G,KAAO7G,KAAK0D,MAAMoB,OACvB9E,KAAK0D,MAAQ1D,KAAKiI,OAAOK,QAU7B,WAAW/I,GACT,MAAM6G,EAAMD,SAAS5G,EAAG,IACxB,GAAIA,IAAM6G,GAAOA,EAAM,EACrB,KAAM,0DACD,GAAY,IAARA,EACT,OAAO,EAGT,GAAI7G,EAAI,EACN,KACE,6BACAA,EACA,sEAIJ,GAAIS,KAAKuI,kBAAoBnC,EAC3B,KACE,4DACAA,EACA,SACApG,KAAK6G,IACL,kBACA7G,KAAKuI,kBAIT,IAAIjC,EAAS,EACTkC,EAAUxI,KAAK0D,MACf+E,EAAY,EACZ5B,EAAM7G,KAAK6G,IACf,IAAK,IAAI/I,EAAI,EAAGA,EAAIsI,IAAOtI,EACzBwI,GAAUkC,EAAQ3B,MAAe,EAAJ/I,EAEzB+I,GAAO2B,EAAQ1D,SACjB0D,EAAUxI,KAAKiI,OAAOQ,KACtB5B,EAAM,GAIV,OAAOP,EAST,WAAW/G,GACT,MAAM6G,EAAMpG,KAAK0I,WAAWnJ,GAE5B,OADAS,KAAK2I,aAAapJ,GACX6G,EAST,iBAAiB7G,GACf,IAAI6G,EAAMpG,KAAK0I,WAAWnJ,GAC1B,MAAMoI,EAAOV,KAAKO,IAAI,EAAO,EAAJjI,EAAQ,GAKjC,OAFI6G,GAAOuB,IAAMvB,GAFG,EAAPuB,GAINvB,EAQT,iBAAiB7G,GACf,MAAM6G,EAAMpG,KAAK4I,iBAAiBrJ,GAElC,OADAS,KAAK2I,aAAapJ,GACX6G,EAUT,UAAU7G,EAAG8G,GACX,MAAMD,EAAMD,SAAS5G,EAAG,IACxB,GAAIA,IAAM6G,GAAOA,EAAM,EACrB,KAAM,yDACD,GAAY,IAARA,EACT,OAAO,IAAInB,WAIb,GAAImB,EADmBpG,KAAKuI,kBAE1B,KACE,0DACAnC,EACA,SACApG,KAAK6G,IACL,kBACA7G,KAAKuI,kBAIT,MAAMjC,EAAS,IAAIrB,WAAWmB,GAC9B,IAAIoC,EAAUxI,KAAK0D,MACfmD,EAAM7G,KAAK6G,IACXC,EAAkBV,EAClBqC,EAAY,EAChB,KAAO3B,EAAkB,GAAG,CAC1B,MAAM+B,EAAkBL,EAAQ1D,OAAS+B,EACnCG,EAAeC,KAAKC,IAAIJ,EAAiB+B,GAE/CvC,EAAOa,IACLqB,EAAQtD,SAAS2B,EAAKA,EAAMG,GAC5BZ,EAAMU,GAGRD,GAAOG,EACHH,GAAO2B,EAAQ1D,SACjB0D,EAAUxI,KAAKiI,OAAOQ,KACtB5B,EAAM,GAGRC,GAAmBE,EAOrB,OAJIX,GACFrG,KAAK2I,aAAavC,GAGbE,EAQT,UAAU/G,GACR,OAAOS,KAAKoH,UAAU7H,GAAG,GAQ3B,WAAWA,GACT,MAAM6G,EAAMD,SAAS5G,EAAG,IACxB,GAAIA,IAAM6G,GAAOA,EAAM,EACrB,KAAM,0DACD,GAAY,IAARA,EACT,MAAO,GAIT,GAAIA,EADmBpG,KAAKuI,kBAE1B,KACE,4DACAnC,EACA,SACApG,KAAK6G,IACL,kBACA7G,KAAKuI,kBAIT,IAAIjC,EAAS,IAAI/D,MAAM6D,GACnBoC,EAAUxI,KAAK0D,MACf+E,EAAY,EACZ5B,EAAM7G,KAAK6G,IACf,IAAK,IAAI/I,EAAI,EAAGA,EAAIsI,IAAOtI,EACzBwI,EAAOxI,GAAKgL,OAAOC,aAAaP,EAAQ3B,MACpCA,GAAO2B,EAAQ1D,SACjB0D,EAAUxI,KAAKiI,OAAOQ,KACtB5B,EAAM,GAIV,OAAOP,EAAO0C,KAAK,IASrB,WAAWzJ,GACT,MAAM0J,EAAcjJ,KAAKkJ,WAAW3J,GAEpC,OADAS,KAAK2I,aAAapJ,GACX0J,EAOT,KAAKrH,GACH,KAAMA,aAAc4D,aAClB,KAAM,qEAGRxF,KAAKiI,OAAOhG,KAAK,IAAIgD,WAAWrD,IAGhC5B,KAAK2I,aAAa,GAOpB,MACE,MAAMQ,EAAQ,IAAInB,EAAWhI,KAAK0D,MAAM0F,QAKxC,OAJAD,EAAMzF,MAAQ1D,KAAK0D,MACnByF,EAAMtC,IAAM7G,KAAK6G,IACjBsC,EAAMlB,OAASjI,KAAKiI,OAAOoB,QAC3BF,EAAMjB,WAAalI,KAAKkI,WACjBiB","file":"bitjs.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bitjs\"] = factory();\n\telse\n\t\troot[\"bitjs\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","/**\n * archive.js\n *\n * Provides base functionality for unarchiving.\n *\n * Licensed under the MIT License\n *\n * Copyright(c) 2011 Google Inc.\n */\n\nimport { findMimeType } from \"../file/sniffer.js\";\nimport unrarWorkerUrl from \"worker-plugin/loader?name=0!./unrar.js\";\nimport untarWorkerUrl from \"worker-plugin/loader?name=1!./untar.js\";\nimport unzipWorkerUrl from \"worker-plugin/loader?name=2!./unzip.js\";\n\n/**\n * An unarchive event.\n */\nexport class UnarchiveEvent {\n  /**\n   * @param {string} type The event type.\n   */\n  constructor(type) {\n    /**\n     * The event type.\n     * @type {string}\n     */\n    this.type = type;\n  }\n}\n\n/**\n * The UnarchiveEvent types.\n */\nexport const UnarchiveEventType = {\n  START: \"start\",\n  PROGRESS: \"progress\",\n  EXTRACT: \"extract\",\n  FINISH: \"finish\",\n  INFO: \"info\",\n  ERROR: \"error\",\n};\n\n/**\n * Useful for passing info up to the client (for debugging).\n */\nexport class UnarchiveInfoEvent extends UnarchiveEvent {\n  /**\n   * @param {string} msg The info message.\n   */\n  constructor(msg) {\n    super(UnarchiveEventType.INFO);\n\n    /**\n     * The information message.\n     * @type {string}\n     */\n    this.msg = msg;\n  }\n}\n\n/**\n * An unrecoverable error has occured.\n */\nexport class UnarchiveErrorEvent extends UnarchiveEvent {\n  /**\n   * @param {string} msg The error message.\n   */\n  constructor(msg) {\n    super(UnarchiveEventType.ERROR);\n\n    /**\n     * The information message.\n     * @type {string}\n     */\n    this.msg = msg;\n  }\n}\n\n/**\n * Start event.\n */\nexport class UnarchiveStartEvent extends UnarchiveEvent {\n  constructor() {\n    super(UnarchiveEventType.START);\n  }\n}\n\n/**\n * Finish event.\n */\nexport class UnarchiveFinishEvent extends UnarchiveEvent {\n  /**\n   * @param {Object} metadata A collection fo metadata about the archive file.\n   */\n  constructor(metadata = {}) {\n    super(UnarchiveEventType.FINISH);\n    this.metadata = metadata;\n  }\n}\n\n/**\n * Progress event.\n */\nexport class UnarchiveProgressEvent extends UnarchiveEvent {\n  /**\n   * @param {string} currentFilename\n   * @param {number} currentFileNumber\n   * @param {number} currentBytesUnarchivedInFile\n   * @param {number} currentBytesUnarchived\n   * @param {number} totalUncompressedBytesInArchive\n   * @param {number} totalFilesInArchive\n   * @param {number} totalCompressedBytesRead\n   */\n  constructor(\n    currentFilename,\n    currentFileNumber,\n    currentBytesUnarchivedInFile,\n    currentBytesUnarchived,\n    totalUncompressedBytesInArchive,\n    totalFilesInArchive,\n    totalCompressedBytesRead\n  ) {\n    super(UnarchiveEventType.PROGRESS);\n\n    this.currentFilename = currentFilename;\n    this.currentFileNumber = currentFileNumber;\n    this.currentBytesUnarchivedInFile = currentBytesUnarchivedInFile;\n    this.totalFilesInArchive = totalFilesInArchive;\n    this.currentBytesUnarchived = currentBytesUnarchived;\n    this.totalUncompressedBytesInArchive = totalUncompressedBytesInArchive;\n    this.totalCompressedBytesRead = totalCompressedBytesRead;\n  }\n}\n\n/**\n * Extract event.\n */\nexport class UnarchiveExtractEvent extends UnarchiveEvent {\n  /**\n   * @param {UnarchivedFile} unarchivedFile\n   */\n  constructor(unarchivedFile) {\n    super(UnarchiveEventType.EXTRACT);\n\n    /**\n     * @type {UnarchivedFile}\n     */\n    this.unarchivedFile = unarchivedFile;\n  }\n}\n\n/**\n * All extracted files returned by an Unarchiver will implement\n * the following interface:\n *\n * interface UnarchivedFile {\n *   string filename\n *   TypedArray fileData\n * }\n *\n */\n\n/**\n * Base class for all Unarchivers.\n */\nexport class Unarchiver {\n  /**\n   * @param {ArrayBuffer} arrayBuffer The Array Buffer.\n   * @param {string} opt_pathToBitJS Optional string for where the BitJS files are located.\n   */\n  constructor(arrayBuffer, workerRootPath) {\n    /**\n     * The ArrayBuffer object.\n     * @type {ArrayBuffer}\n     * @protected\n     */\n    this.ab = arrayBuffer;\n\n    /**\n     * The path to the BitJS files.\n     * @type {string}\n     * @private\n     */\n    this.workerRootPath = workerRootPath;\n\n    /**\n     * A map from event type to an array of listeners.\n     * @type {Map.<string, Array>}\n     */\n    this.listeners_ = {};\n    for (let type in UnarchiveEventType) {\n      this.listeners_[UnarchiveEventType[type]] = [];\n    }\n\n    /**\n     * Private web worker initialized during start().\n     * @type {Worker}\n     * @private\n     */\n    this.worker_ = null;\n  }\n\n  /**\n   * This method must be overridden by the subclass to return the worker.\n   * @return {any} The worker.\n   * @protected.\n   */\n  getWorker() {\n    throw \"Subclasses of AbstractUnarchiver must overload getWorker()\";\n  }\n\n  /**\n   * Adds an event listener for UnarchiveEvents.\n   *\n   * @param {string} Event type.\n   * @param {function} An event handler function.\n   */\n  addEventListener(type, listener) {\n    if (type in this.listeners_) {\n      if (this.listeners_[type].indexOf(listener) == -1) {\n        this.listeners_[type].push(listener);\n      }\n    }\n  }\n\n  /**\n   * Removes an event listener.\n   *\n   * @param {string} Event type.\n   * @param {EventListener|function} An event listener or handler function.\n   */\n  removeEventListener(type, listener) {\n    if (type in this.listeners_) {\n      const index = this.listeners_[type].indexOf(listener);\n      if (index != -1) {\n        this.listeners_[type].splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Create an UnarchiveEvent out of the object sent back from the Worker.\n   * @param {Object} obj\n   * @return {UnarchiveEvent}\n   * @private\n   */\n  createUnarchiveEvent_(obj) {\n    switch (obj.type) {\n      case UnarchiveEventType.START:\n        return new UnarchiveStartEvent();\n      case UnarchiveEventType.PROGRESS:\n        return new UnarchiveProgressEvent(\n          obj.currentFilename,\n          obj.currentFileNumber,\n          obj.currentBytesUnarchivedInFile,\n          obj.currentBytesUnarchived,\n          obj.totalUncompressedBytesInArchive,\n          obj.totalFilesInArchive,\n          obj.totalCompressedBytesRead\n        );\n      case UnarchiveEventType.EXTRACT:\n        return new UnarchiveExtractEvent(obj.unarchivedFile);\n      case UnarchiveEventType.FINISH:\n        return new UnarchiveFinishEvent(obj.metadata);\n      case UnarchiveEventType.INFO:\n        return new UnarchiveInfoEvent(obj.msg);\n      case UnarchiveEventType.ERROR:\n        return new UnarchiveErrorEvent(obj.msg);\n    }\n  }\n\n  /**\n   * Receive an event and pass it to the listener functions.\n   *\n   * @param {Object} obj\n   * @private\n   */\n  handleWorkerEvent_(obj) {\n    const type = obj.type;\n    if (\n      type &&\n      Object.values(UnarchiveEventType).includes(type) &&\n      this.listeners_[obj.type] instanceof Array\n    ) {\n      const evt = this.createUnarchiveEvent_(obj);\n      this.listeners_[evt.type].forEach(function (listener) {\n        listener(evt);\n      });\n      if (evt.type == UnarchiveEventType.FINISH) {\n        this.worker_.terminate();\n      }\n    } else {\n      console.log(`Unknown object received from worker: ${obj}`);\n    }\n  }\n\n  /**\n   * Starts the unarchive in a separate Web Worker thread and returns immediately.\n   */\n  start() {\n    const me = this;\n    const worker = this.getWorker();\n    if (worker) {\n      this.worker_ = worker;\n\n      this.worker_.onerror = function (e) {\n        console.log(\"Worker error: message = \" + e.message);\n        throw e;\n      };\n\n      this.worker_.onmessage = function (e) {\n        if (typeof e.data == \"string\") {\n          // Just log any strings the workers pump our way.\n          console.log(e.data);\n        } else {\n          me.handleWorkerEvent_(e.data);\n        }\n      };\n\n      const ab = this.ab;\n      this.worker_.postMessage({\n        file: ab,\n        logToConsole: false,\n      });\n      this.ab = null;\n    }\n  }\n\n  /**\n   * Adds more bytes to the unarchiver's Worker thread.\n   * @param {ArrayBuffer} ab The ArrayBuffer with more bytes in it.\n   */\n  update(ab) {\n    if (this.worker_) {\n      this.worker_.postMessage({ bytes: ab });\n    }\n  }\n\n  /**\n   * Terminates the Web Worker for this Unarchiver and returns immediately.\n   */\n  stop() {\n    if (this.worker_) {\n      this.worker_.terminate();\n    }\n  }\n}\n\n/**\n * Unzipper\n */\nexport class Unzipper extends Unarchiver {\n  constructor(arrayBuffer, workerRootPath = null) {\n    super(arrayBuffer, workerRootPath);\n  }\n\n  getWorker() {\n    if (this.workerRootPath) {\n      return new Worker(this.workerRootPath + \"/\" + unzipWorkerUrl);\n    }\n    return new Worker(\"./unzip.js\", { type: \"module\" });\n  }\n}\n\n/**\n * Unrarrer\n */\nexport class Unrarrer extends Unarchiver {\n  constructor(arrayBuffer, workerRootPath = null) {\n    super(arrayBuffer, workerRootPath);\n  }\n\n  getWorker() {\n    if (this.workerRootPath) {\n      return new Worker(this.workerRootPath + \"/\" + unrarWorkerUrl);\n    }\n    return new Worker(\"./unrar.js\", { type: \"module\" });\n  }\n}\n\n/**\n * Untarrer\n * @extends {Unarchiver}\n * @constructor\n */\nexport class Untarrer extends Unarchiver {\n  constructor(arrayBuffer, workerRootPath = null) {\n    super(arrayBuffer, workerRootPath);\n  }\n\n  getWorker() {\n    if (this.workerRootPath) {\n      return new Worker(this.workerRootPath + \"/\" + untarWorkerUrl);\n    }\n    return new Worker(\"./untar.js\", { type: \"module\" });\n  }\n}\n\n/**\n * Factory method that creates an unarchiver based on the byte signature found\n * in the arrayBuffer.\n * @param {ArrayBuffer} ab\n * @param {string=} workerRootPath Path to the unarchiver script files.\n * @return {Unarchiver}\n */\nexport function getUnarchiver(ab, workerRootPath = null) {\n  if (ab.byteLength < 10) {\n    return null;\n  }\n\n  let unarchiver = null;\n  const mimeType = findMimeType(ab);\n  if (mimeType === \"application/x-rar-compressed\") {\n    // Rar!\n    unarchiver = new Unrarrer(ab, workerRootPath);\n  } else if (mimetype === \"application/zip\") {\n    // PK (Zip)\n    unarchiver = new Unzipper(ab, workerRootPath);\n  } else {\n    // Try with tar\n    unarchiver = new Untarrer(ab, workerRootPath);\n  }\n  return unarchiver;\n}\n","/**\n * File Sniffer.\n *\n * Licensed under the MIT License\n *\n * Copyright(c) 2020 Google Inc.\n */\n\n// A selection from https://en.wikipedia.org/wiki/List_of_file_signatures.\n// Mapping of MIME type to magic numbers.  Each file type can have multiple signatures.\n// '??' is used as a placeholder value.\n// TODO:  Add audio/video formats?\nconst fileSignatures = {\n  // Document formats.\n  \"application/pdf\": [[0x25, 0x50, 0x44, 0x46, 0x2d]],\n  // Compressed archive formats.\n  \"application/x-7z-compressed\": [[0x37, 0x7a, 0xbc, 0xaf, 0x27, 0x1c]],\n  \"application/x-bzip2\": [[0x42, 0x5a, 0x68]],\n  \"application/x-rar-compressed\": [[0x52, 0x61, 0x72, 0x21, 0x1a, 0x07]],\n  \"application/zip\": [\n    [0x50, 0x4b, 0x03, 0x04],\n    [0x50, 0x4b, 0x05, 0x06],\n    [0x50, 0x4b, 0x07, 0x08],\n  ],\n  // Image formats.\n  \"image/bmp\": [[0x42, 0x4d]],\n  \"image/gif\": [[0x47, 0x49, 0x46, 0x38]],\n  \"image/jpeg\": [[0xff, 0xd8, 0xff]],\n  \"image/png\": [[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]],\n  \"image/webp\": [\n    [0x52, 0x49, 0x46, 0x46, \"??\", \"??\", \"??\", \"??\", 0x57, 0x45, 0x42, 0x50],\n  ],\n};\n\nclass Node {\n  /** @param {number} value */\n  constructor(value) {\n    this.value = value;\n    this.children = {};\n    this.mimeType = undefined;\n  }\n}\n\n// Top-level node in the tree.\nconst root = new Node();\nlet maxDepth = 0;\n\n// Construct the tree, erroring if overlapping mime types are possible.\nfor (const mimeType in fileSignatures) {\n  for (const signature of fileSignatures[mimeType]) {\n    let curNode = root;\n    let depth = 0;\n    for (const byte of signature) {\n      if (curNode.children[byte] === undefined) {\n        if (\n          byte === \"??\" &&\n          !curNode.children[\"??\"] &&\n          Object.keys(curNode.children).length > 0\n        ) {\n          throw \"Cannot add a placeholder child to a node that has non-placeholder children\";\n        } else if (byte !== \"??\" && curNode.children[\"??\"]) {\n          throw \"Cannot add a non-placeholder child to a node that has a placeholder child\";\n        }\n        curNode.children[byte] = new Node(byte);\n      }\n      depth++;\n      curNode = curNode.children[byte];\n    } // for each byte\n\n    if (maxDepth < depth) {\n      maxDepth = depth;\n    }\n\n    if (curNode.mimeType) {\n      throw `File signature collision:  ${curNode.mimeType} overlaps with ${mimeType}`;\n    } else if (Object.keys(curNode.children).length > 0) {\n      throw `${mimeType} signature is not unique, it collides with other mime types`;\n    }\n    curNode.mimeType = mimeType;\n  } // for each signature\n}\n\n/**\n * @param {ArrayBuffer} ab\n * @return {string} The MIME type of the buffer, or undefined.\n */\nexport function findMimeType(ab) {\n  const depth = ab.byteLength < maxDepth ? ab.byteLength : maxDepth;\n  const arr = new Uint8Array(ab).subarray(0, depth);\n  let curNode = root;\n  for (const byte of arr) {\n    // If this node has a placeholder child, just step into it.\n    if (curNode.children[\"??\"]) {\n      curNode = curNode.children[\"??\"];\n      continue;\n    }\n    if (curNode.children[byte] === undefined) return undefined;\n    curNode = curNode.children[byte];\n    if (curNode.mimeType) return curNode.mimeType;\n  }\n}\n","module.exports = __webpack_public_path__ + \"bitjs.0.worker.js\"","module.exports = __webpack_public_path__ + \"bitjs.1.worker.js\"","module.exports = __webpack_public_path__ + \"bitjs.2.worker.js\"","module.exports = __webpack_public_path__ + \"bitjs.0.worker.js\"","module.exports = __webpack_public_path__ + \"bitjs.1.worker.js\"","module.exports = __webpack_public_path__ + \"bitjs.2.worker.js\"","/*\n * bitstream.js\n *\n * Provides readers for bitstreams.\n *\n * Licensed under the MIT License\n *\n * Copyright(c) 2011 Google Inc.\n * Copyright(c) 2011 antimatter15\n */\n\n// mask for getting N number of bits (0-8)\nconst BITMASK = [0, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff];\n\n/**\n * This object allows you to peek and consume bits and bytes out of a stream.\n * Note that this stream is optimized, and thus, will *NOT* throw an error if\n * the end of the stream is reached.  Only use this in scenarios where you\n * already have all the bits you need.\n */\nexport class BitStream {\n  /**\n   * @param {ArrayBuffer} ab An ArrayBuffer object or a Uint8Array.\n   * @param {boolean} rtl Whether the stream reads bits from the byte starting\n   *     from bit 7 to 0 (true) or bit 0 to 7 (false).\n   * @param {Number} opt_offset The offset into the ArrayBuffer\n   * @param {Number} opt_length The length of this BitStream\n   */\n  constructor(ab, rtl, opt_offset, opt_length) {\n    if (!(ab instanceof ArrayBuffer)) {\n      throw \"Error! BitArray constructed with an invalid ArrayBuffer object\";\n    }\n\n    const offset = opt_offset || 0;\n    const length = opt_length || ab.byteLength;\n\n    /**\n     * The bytes in the stream.\n     * @type {Uint8Array}\n     * @private\n     */\n    this.bytes = new Uint8Array(ab, offset, length);\n\n    /**\n     * The byte in the stream that we are currently on.\n     * @type {Number}\n     * @private\n     */\n    this.bytePtr = 0;\n\n    /**\n     * The bit in the current byte that we will read next (can have values 0 through 7).\n     * @type {Number}\n     * @private\n     */\n    this.bitPtr = 0; // tracks which bit we are on (can have values 0 through 7)\n\n    /**\n     * An ever-increasing number.\n     * @type {Number}\n     * @private\n     */\n    this.bitsRead_ = 0;\n\n    this.peekBits = rtl ? this.peekBits_rtl : this.peekBits_ltr;\n  }\n\n  /**\n   * Returns how many bites have been read in the stream since the beginning of time.\n   */\n  getNumBitsRead() {\n    return this.bitsRead_;\n  }\n\n  /**\n   * Returns how many bits are currently in the stream left to be read.\n   */\n  getNumBitsLeft() {\n    const bitsLeftInByte = 8 - this.bitPtr;\n    return (this.bytes.byteLength - this.bytePtr - 1) * 8 + bitsLeftInByte;\n  }\n\n  /**\n   *   byte0      byte1      byte2      byte3\n   * 7......0 | 7......0 | 7......0 | 7......0\n   *\n   * The bit pointer starts at bit0 of byte0 and moves left until it reaches\n   * bit7 of byte0, then jumps to bit0 of byte1, etc.\n   * @param {number} n The number of bits to peek, must be a positive integer.\n   * @param {boolean=} movePointers Whether to move the pointer, defaults false.\n   * @return {number} The peeked bits, as an unsigned number.\n   */\n  peekBits_ltr(n, opt_movePointers) {\n    const NUM = parseInt(n, 10);\n    let num = NUM;\n    if (n !== num || num <= 0) {\n      return 0;\n    }\n\n    const movePointers = opt_movePointers || false;\n    let bytes = this.bytes;\n    let bytePtr = this.bytePtr;\n    let bitPtr = this.bitPtr;\n    let result = 0;\n    let bitsIn = 0;\n\n    // keep going until we have no more bits left to peek at\n    while (num > 0) {\n      // We overflowed the stream, so just return what we got.\n      if (bytePtr >= bytes.length) {\n        break;\n      }\n\n      const numBitsLeftInThisByte = 8 - bitPtr;\n      if (num >= numBitsLeftInThisByte) {\n        const mask = BITMASK[numBitsLeftInThisByte] << bitPtr;\n        result |= ((bytes[bytePtr] & mask) >> bitPtr) << bitsIn;\n\n        bytePtr++;\n        bitPtr = 0;\n        bitsIn += numBitsLeftInThisByte;\n        num -= numBitsLeftInThisByte;\n      } else {\n        const mask = BITMASK[num] << bitPtr;\n        result |= ((bytes[bytePtr] & mask) >> bitPtr) << bitsIn;\n\n        bitPtr += num;\n        break;\n      }\n    }\n\n    if (movePointers) {\n      this.bitPtr = bitPtr;\n      this.bytePtr = bytePtr;\n      this.bitsRead_ += NUM;\n    }\n\n    return result;\n  }\n\n  /**\n   *   byte0      byte1      byte2      byte3\n   * 7......0 | 7......0 | 7......0 | 7......0\n   *\n   * The bit pointer starts at bit7 of byte0 and moves right until it reaches\n   * bit0 of byte0, then goes to bit7 of byte1, etc.\n   * @param {number} n The number of bits to peek.  Must be a positive integer.\n   * @param {boolean=} movePointers Whether to move the pointer, defaults false.\n   * @return {number} The peeked bits, as an unsigned number.\n   */\n  peekBits_rtl(n, opt_movePointers) {\n    const NUM = parseInt(n, 10);\n    let num = NUM;\n    if (n !== num || num <= 0) {\n      return 0;\n    }\n\n    const movePointers = opt_movePointers || false;\n    let bytes = this.bytes;\n    let bytePtr = this.bytePtr;\n    let bitPtr = this.bitPtr;\n    let result = 0;\n\n    // keep going until we have no more bits left to peek at\n    while (num > 0) {\n      // We overflowed the stream, so just return the bits we got.\n      if (bytePtr >= bytes.length) {\n        break;\n      }\n\n      const numBitsLeftInThisByte = 8 - bitPtr;\n      if (num >= numBitsLeftInThisByte) {\n        result <<= numBitsLeftInThisByte;\n        result |= BITMASK[numBitsLeftInThisByte] & bytes[bytePtr];\n        bytePtr++;\n        bitPtr = 0;\n        num -= numBitsLeftInThisByte;\n      } else {\n        result <<= num;\n        const numBits = 8 - num - bitPtr;\n        result |= (bytes[bytePtr] & (BITMASK[num] << numBits)) >> numBits;\n\n        bitPtr += num;\n        break;\n      }\n    }\n\n    if (movePointers) {\n      this.bitPtr = bitPtr;\n      this.bytePtr = bytePtr;\n      this.bitsRead_ += NUM;\n    }\n\n    return result;\n  }\n\n  /**\n   * Peek at 16 bits from current position in the buffer.\n   * Bit at (bytePtr,bitPtr) has the highest position in returning data.\n   * Taken from getbits.hpp in unrar.\n   * TODO: Move this out of BitStream and into unrar.\n   */\n  getBits() {\n    return (\n      ((((this.bytes[this.bytePtr] & 0xff) << 16) +\n        ((this.bytes[this.bytePtr + 1] & 0xff) << 8) +\n        (this.bytes[this.bytePtr + 2] & 0xff)) >>>\n        (8 - this.bitPtr)) &\n      0xffff\n    );\n  }\n\n  /**\n   * Reads n bits out of the stream, consuming them (moving the bit pointer).\n   * @param {number} n The number of bits to read.  Must be a positive integer.\n   * @return {number} The read bits, as an unsigned number.\n   */\n  readBits(n) {\n    return this.peekBits(n, true);\n  }\n\n  /**\n   * This returns n bytes as a sub-array, advancing the pointer if movePointers\n   * is true.  Only use this for uncompressed blocks as this throws away remaining\n   * bits in the current byte.\n   * @param {number} n The number of bytes to peek.  Must be a positive integer.\n   * @param {boolean=} movePointers Whether to move the pointer, defaults false.\n   * @return {Uint8Array} The subarray.\n   */\n  peekBytes(n, opt_movePointers) {\n    const num = parseInt(n, 10);\n    if (n !== num || num < 0) {\n      throw \"Error!  Called peekBytes() with a non-positive integer: \" + n;\n    } else if (num === 0) {\n      return new Uint8Array();\n    }\n\n    // Flush bits until we are byte-aligned.\n    // from http://tools.ietf.org/html/rfc1951#page-11\n    // \"Any bits of input up to the next byte boundary are ignored.\"\n    while (this.bitPtr != 0) {\n      this.readBits(1);\n    }\n\n    const numBytesLeft = this.getNumBitsLeft() / 8;\n    if (num > numBytesLeft) {\n      throw (\n        \"Error!  Overflowed the bit stream! n=\" +\n        num +\n        \", bytePtr=\" +\n        this.bytePtr +\n        \", bytes.length=\" +\n        this.bytes.length +\n        \", bitPtr=\" +\n        this.bitPtr\n      );\n    }\n\n    const movePointers = opt_movePointers || false;\n    const result = new Uint8Array(num);\n    let bytes = this.bytes;\n    let ptr = this.bytePtr;\n    let bytesLeftToCopy = num;\n    while (bytesLeftToCopy > 0) {\n      const bytesLeftInStream = bytes.length - ptr;\n      const sourceLength = Math.min(bytesLeftToCopy, bytesLeftInStream);\n\n      result.set(\n        bytes.subarray(ptr, ptr + sourceLength),\n        num - bytesLeftToCopy\n      );\n\n      ptr += sourceLength;\n      // Overflowed the stream, just return what we got.\n      if (ptr >= bytes.length) {\n        break;\n      }\n\n      bytesLeftToCopy -= sourceLength;\n    }\n\n    if (movePointers) {\n      this.bytePtr += num;\n      this.bitsRead_ += num * 8;\n    }\n\n    return result;\n  }\n\n  /**\n   * @param {number} n The number of bytes to read.\n   * @return {Uint8Array} The subarray.\n   */\n  readBytes(n) {\n    return this.peekBytes(n, true);\n  }\n}\n\nexport default BitStream;\n","/*\n * bytebuffer.js\n *\n * Provides a writer for bytes.\n *\n * Licensed under the MIT License\n *\n * Copyright(c) 2011 Google Inc.\n * Copyright(c) 2011 antimatter15\n */\n\n/**\n * A write-only Byte buffer which uses a Uint8 Typed Array as a backing store.\n */\nexport class ByteBuffer {\n  /**\n   * @param {number} numBytes The number of bytes to allocate.\n   */\n  constructor(numBytes) {\n    if (typeof numBytes != typeof 1 || numBytes <= 0) {\n      throw \"Error! ByteBuffer initialized with '\" + numBytes + \"'\";\n    }\n    this.data = new Uint8Array(numBytes);\n    this.ptr = 0;\n  }\n\n  /**\n   * @param {number} b The byte to insert.\n   */\n  insertByte(b) {\n    // TODO: throw if byte is invalid?\n    this.data[this.ptr++] = b;\n  }\n\n  /**\n   * @param {Array.<number>|Uint8Array|Int8Array} bytes The bytes to insert.\n   */\n  insertBytes(bytes) {\n    // TODO: throw if bytes is invalid?\n    this.data.set(bytes, this.ptr);\n    this.ptr += bytes.length;\n  }\n\n  /**\n   * Writes an unsigned number into the next n bytes.  If the number is too large\n   * to fit into n bytes or is negative, an error is thrown.\n   * @param {number} num The unsigned number to write.\n   * @param {number} numBytes The number of bytes to write the number into.\n   */\n  writeNumber(num, numBytes) {\n    if (numBytes < 1 || !numBytes) {\n      throw \"Trying to write into too few bytes: \" + numBytes;\n    }\n    if (num < 0) {\n      throw (\n        \"Trying to write a negative number (\" +\n        num +\n        \") as an unsigned number to an ArrayBuffer\"\n      );\n    }\n    if (num > Math.pow(2, numBytes * 8) - 1) {\n      throw \"Trying to write \" + num + \" into only \" + numBytes + \" bytes\";\n    }\n\n    // Roll 8-bits at a time into an array of bytes.\n    const bytes = [];\n    while (numBytes-- > 0) {\n      const eightBits = num & 255;\n      bytes.push(eightBits);\n      num >>= 8;\n    }\n\n    this.insertBytes(bytes);\n  }\n\n  /**\n   * Writes a signed number into the next n bytes.  If the number is too large\n   * to fit into n bytes, an error is thrown.\n   * @param {number} num The signed number to write.\n   * @param {number} numBytes The number of bytes to write the number into.\n   */\n  writeSignedNumber(num, numBytes) {\n    if (numBytes < 1) {\n      throw \"Trying to write into too few bytes: \" + numBytes;\n    }\n\n    const HALF = Math.pow(2, numBytes * 8 - 1);\n    if (num >= HALF || num < -HALF) {\n      throw \"Trying to write \" + num + \" into only \" + numBytes + \" bytes\";\n    }\n\n    // Roll 8-bits at a time into an array of bytes.\n    const bytes = [];\n    while (numBytes-- > 0) {\n      const eightBits = num & 255;\n      bytes.push(eightBits);\n      num >>= 8;\n    }\n\n    this.insertBytes(bytes);\n  }\n\n  /**\n   * @param {string} str The ASCII string to write.\n   */\n  writeASCIIString(str) {\n    for (let i = 0; i < str.length; ++i) {\n      const curByte = str.charCodeAt(i);\n      if (curByte < 0 || curByte > 255) {\n        throw \"Trying to write a non-ASCII string!\";\n      }\n      this.insertByte(curByte);\n    }\n  }\n}\n\nexport default ByteBuffer;\n","/*\n * bytestream.js\n *\n * Provides readers for byte streams.\n *\n * Licensed under the MIT License\n *\n * Copyright(c) 2011 Google Inc.\n * Copyright(c) 2011 antimatter15\n */\n\n/**\n * This object allows you to peek and consume bytes as numbers and strings out\n * of a stream.  More bytes can be pushed into the back of the stream via the\n * push() method.\n */\nexport class ByteStream {\n  /**\n   * @param {ArrayBuffer} ab The ArrayBuffer object.\n   * @param {number=} opt_offset The offset into the ArrayBuffer\n   * @param {number=} opt_length The length of this ByteStream\n   */\n  constructor(ab, opt_offset, opt_length) {\n    if (!(ab instanceof ArrayBuffer)) {\n      throw \"Error! BitArray constructed with an invalid ArrayBuffer object\";\n    }\n\n    const offset = opt_offset || 0;\n    const length = opt_length || ab.byteLength;\n\n    /**\n     * The current page of bytes in the stream.\n     * @type {Uint8Array}\n     * @private\n     */\n    this.bytes = new Uint8Array(ab, offset, length);\n\n    /**\n     * The next pages of bytes in the stream.\n     * @type {Array<Uint8Array>}\n     * @private\n     */\n    this.pages_ = [];\n\n    /**\n     * The byte in the current page that we will read next.\n     * @type {Number}\n     * @private\n     */\n    this.ptr = 0;\n\n    /**\n     * An ever-increasing number.\n     * @type {Number}\n     * @private\n     */\n    this.bytesRead_ = 0;\n  }\n\n  /**\n   * Returns how many bytes have been read in the stream since the beginning of time.\n   */\n  getNumBytesRead() {\n    return this.bytesRead_;\n  }\n\n  /**\n   * Returns how many bytes are currently in the stream left to be read.\n   */\n  getNumBytesLeft() {\n    const bytesInCurrentPage = this.bytes.byteLength - this.ptr;\n    return this.pages_.reduce(\n      (acc, arr) => acc + arr.length,\n      bytesInCurrentPage\n    );\n  }\n\n  /**\n   * Move the pointer ahead n bytes.  If the pointer is at the end of the current array\n   * of bytes and we have another page of bytes, point at the new page.  This is a private\n   * method, no validation is done.\n   * @param {number} n Number of bytes to increment.\n   * @private\n   */\n  movePointer_(n) {\n    this.ptr += n;\n    this.bytesRead_ += n;\n    while (this.ptr >= this.bytes.length && this.pages_.length > 0) {\n      this.ptr -= this.bytes.length;\n      this.bytes = this.pages_.shift();\n    }\n  }\n\n  /**\n   * Peeks at the next n bytes as an unsigned number but does not advance the\n   * pointer.\n   * @param {number} n The number of bytes to peek at.  Must be a positive integer.\n   * @return {number} The n bytes interpreted as an unsigned number.\n   */\n  peekNumber(n) {\n    const num = parseInt(n, 10);\n    if (n !== num || num < 0) {\n      throw \"Error!  Called peekNumber() with a non-positive integer\";\n    } else if (num === 0) {\n      return 0;\n    }\n\n    if (n > 4) {\n      throw (\n        \"Error!  Called peekNumber(\" +\n        n +\n        \") but this method can only reliably read numbers up to 4 bytes long\"\n      );\n    }\n\n    if (this.getNumBytesLeft() < num) {\n      throw (\n        \"Error!  Overflowed the byte stream while peekNumber()! n=\" +\n        num +\n        \", ptr=\" +\n        this.ptr +\n        \", bytes.length=\" +\n        this.getNumBytesLeft()\n      );\n    }\n\n    let result = 0;\n    let curPage = this.bytes;\n    let pageIndex = 0;\n    let ptr = this.ptr;\n    for (let i = 0; i < num; ++i) {\n      result |= curPage[ptr++] << (i * 8);\n\n      if (ptr >= curPage.length) {\n        curPage = this.pages_[pageIndex++];\n        ptr = 0;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the next n bytes as an unsigned number (or -1 on error)\n   * and advances the stream pointer n bytes.\n   * @param {number} n The number of bytes to read.  Must be a positive integer.\n   * @return {number} The n bytes interpreted as an unsigned number.\n   */\n  readNumber(n) {\n    const num = this.peekNumber(n);\n    this.movePointer_(n);\n    return num;\n  }\n\n  /**\n   * Returns the next n bytes as a signed number but does not advance the\n   * pointer.\n   * @param {number} n The number of bytes to read.  Must be a positive integer.\n   * @return {number} The bytes interpreted as a signed number.\n   */\n  peekSignedNumber(n) {\n    let num = this.peekNumber(n);\n    const HALF = Math.pow(2, n * 8 - 1);\n    const FULL = HALF * 2;\n\n    if (num >= HALF) num -= FULL;\n\n    return num;\n  }\n\n  /**\n   * Returns the next n bytes as a signed number and advances the stream pointer.\n   * @param {number} n The number of bytes to read.  Must be a positive integer.\n   * @return {number} The bytes interpreted as a signed number.\n   */\n  readSignedNumber(n) {\n    const num = this.peekSignedNumber(n);\n    this.movePointer_(n);\n    return num;\n  }\n\n  /**\n   * This returns n bytes as a sub-array, advancing the pointer if movePointers\n   * is true.\n   * @param {number} n The number of bytes to read.  Must be a positive integer.\n   * @param {boolean} movePointers Whether to move the pointers.\n   * @return {Uint8Array} The subarray.\n   */\n  peekBytes(n, movePointers) {\n    const num = parseInt(n, 10);\n    if (n !== num || num < 0) {\n      throw \"Error!  Called peekBytes() with a non-positive integer\";\n    } else if (num === 0) {\n      return new Uint8Array();\n    }\n\n    const totalBytesLeft = this.getNumBytesLeft();\n    if (num > totalBytesLeft) {\n      throw (\n        \"Error!  Overflowed the byte stream during peekBytes! n=\" +\n        num +\n        \", ptr=\" +\n        this.ptr +\n        \", bytes.length=\" +\n        this.getNumBytesLeft()\n      );\n    }\n\n    const result = new Uint8Array(num);\n    let curPage = this.bytes;\n    let ptr = this.ptr;\n    let bytesLeftToCopy = num;\n    let pageIndex = 0;\n    while (bytesLeftToCopy > 0) {\n      const bytesLeftInPage = curPage.length - ptr;\n      const sourceLength = Math.min(bytesLeftToCopy, bytesLeftInPage);\n\n      result.set(\n        curPage.subarray(ptr, ptr + sourceLength),\n        num - bytesLeftToCopy\n      );\n\n      ptr += sourceLength;\n      if (ptr >= curPage.length) {\n        curPage = this.pages_[pageIndex++];\n        ptr = 0;\n      }\n\n      bytesLeftToCopy -= sourceLength;\n    }\n\n    if (movePointers) {\n      this.movePointer_(num);\n    }\n\n    return result;\n  }\n\n  /**\n   * Reads the next n bytes as a sub-array.\n   * @param {number} n The number of bytes to read.  Must be a positive integer.\n   * @return {Uint8Array} The subarray.\n   */\n  readBytes(n) {\n    return this.peekBytes(n, true);\n  }\n\n  /**\n   * Peeks at the next n bytes as an ASCII string but does not advance the pointer.\n   * @param {number} n The number of bytes to peek at.  Must be a positive integer.\n   * @return {string} The next n bytes as a string.\n   */\n  peekString(n) {\n    const num = parseInt(n, 10);\n    if (n !== num || num < 0) {\n      throw \"Error!  Called peekString() with a non-positive integer\";\n    } else if (num === 0) {\n      return \"\";\n    }\n\n    const totalBytesLeft = this.getNumBytesLeft();\n    if (num > totalBytesLeft) {\n      throw (\n        \"Error!  Overflowed the byte stream while peekString()! n=\" +\n        num +\n        \", ptr=\" +\n        this.ptr +\n        \", bytes.length=\" +\n        this.getNumBytesLeft()\n      );\n    }\n\n    let result = new Array(num);\n    let curPage = this.bytes;\n    let pageIndex = 0;\n    let ptr = this.ptr;\n    for (let i = 0; i < num; ++i) {\n      result[i] = String.fromCharCode(curPage[ptr++]);\n      if (ptr >= curPage.length) {\n        curPage = this.pages_[pageIndex++];\n        ptr = 0;\n      }\n    }\n\n    return result.join(\"\");\n  }\n\n  /**\n   * Returns the next n bytes as an ASCII string and advances the stream pointer\n   * n bytes.\n   * @param {number} n The number of bytes to read.  Must be a positive integer.\n   * @return {string} The next n bytes as a string.\n   */\n  readString(n) {\n    const strToReturn = this.peekString(n);\n    this.movePointer_(n);\n    return strToReturn;\n  }\n\n  /**\n   * Feeds more bytes into the back of the stream.\n   * @param {ArrayBuffer} ab\n   */\n  push(ab) {\n    if (!(ab instanceof ArrayBuffer)) {\n      throw \"Error! ByteStream.push() called with an invalid ArrayBuffer object\";\n    }\n\n    this.pages_.push(new Uint8Array(ab));\n    // If the pointer is at the end of the current page of bytes, this will advance\n    // to the next page.\n    this.movePointer_(0);\n  }\n\n  /**\n   * Creates a new ByteStream from this ByteStream that can be read / peeked.\n   * @return {ByteStream} A clone of this ByteStream.\n   */\n  tee() {\n    const clone = new ByteStream(this.bytes.buffer);\n    clone.bytes = this.bytes;\n    clone.ptr = this.ptr;\n    clone.pages_ = this.pages_.slice();\n    clone.bytesRead_ = this.bytesRead_;\n    return clone;\n  }\n}\n\nexport default ByteStream;\n"],"sourceRoot":""}