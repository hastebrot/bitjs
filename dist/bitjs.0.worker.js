!function(t){var e={};function r(s){if(e[s])return e[s].exports;var i=e[s]={i:s,l:!1,exports:{}};return t[s].call(i.exports,i,i.exports,r),i.l=!0,i.exports}r.m=t,r.c=e,r.d=function(t,e,s){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(s,i,function(e){return t[e]}.bind(null,i));return s},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){"use strict";r.r(e);const s=[0,1,3,7,15,31,63,127,255];var i=class{constructor(t,e,r,s){if(!(t instanceof ArrayBuffer))throw"Error! BitArray constructed with an invalid ArrayBuffer object";const i=r||0,a=s||t.byteLength;this.bytes=new Uint8Array(t,i,a),this.bytePtr=0,this.bitPtr=0,this.bitsRead_=0,this.peekBits=e?this.peekBits_rtl:this.peekBits_ltr}getNumBitsRead(){return this.bitsRead_}getNumBitsLeft(){const t=8-this.bitPtr;return 8*(this.bytes.byteLength-this.bytePtr-1)+t}peekBits_ltr(t,e){const r=parseInt(t,10);let i=r;if(t!==i||i<=0)return 0;const a=e||!1;let n=this.bytes,o=this.bytePtr,l=this.bitPtr,h=0,d=0;for(;i>0&&!(o>=n.length);){const t=8-l;if(!(i>=t)){const t=s[i]<<l;h|=(n[o]&t)>>l<<d,l+=i;break}{const e=s[t]<<l;h|=(n[o]&e)>>l<<d,o++,l=0,d+=t,i-=t}}return a&&(this.bitPtr=l,this.bytePtr=o,this.bitsRead_+=r),h}peekBits_rtl(t,e){const r=parseInt(t,10);let i=r;if(t!==i||i<=0)return 0;const a=e||!1;let n=this.bytes,o=this.bytePtr,l=this.bitPtr,h=0;for(;i>0&&!(o>=n.length);){const t=8-l;if(!(i>=t)){h<<=i;const t=8-i-l;h|=(n[o]&s[i]<<t)>>t,l+=i;break}h<<=t,h|=s[t]&n[o],o++,l=0,i-=t}return a&&(this.bitPtr=l,this.bytePtr=o,this.bitsRead_+=r),h}getBits(){return((255&this.bytes[this.bytePtr])<<16)+((255&this.bytes[this.bytePtr+1])<<8)+(255&this.bytes[this.bytePtr+2])>>>8-this.bitPtr&65535}readBits(t){return this.peekBits(t,!0)}peekBytes(t,e){const r=parseInt(t,10);if(t!==r||r<0)throw"Error!  Called peekBytes() with a non-positive integer: "+t;if(0===r)return new Uint8Array;for(;0!=this.bitPtr;)this.readBits(1);if(r>this.getNumBitsLeft()/8)throw"Error!  Overflowed the bit stream! n="+r+", bytePtr="+this.bytePtr+", bytes.length="+this.bytes.length+", bitPtr="+this.bitPtr;const s=e||!1,i=new Uint8Array(r);let a=this.bytes,n=this.bytePtr,o=r;for(;o>0;){const t=a.length-n,e=Math.min(o,t);if(i.set(a.subarray(n,n+e),r-o),n+=e,n>=a.length)break;o-=e}return s&&(this.bytePtr+=r,this.bitsRead_+=8*r),i}readBytes(t){return this.peekBytes(t,!0)}};class a{constructor(t,e,r){if(!(t instanceof ArrayBuffer))throw"Error! BitArray constructed with an invalid ArrayBuffer object";const s=e||0,i=r||t.byteLength;this.bytes=new Uint8Array(t,s,i),this.pages_=[],this.ptr=0,this.bytesRead_=0}getNumBytesRead(){return this.bytesRead_}getNumBytesLeft(){const t=this.bytes.byteLength-this.ptr;return this.pages_.reduce((t,e)=>t+e.length,t)}movePointer_(t){for(this.ptr+=t,this.bytesRead_+=t;this.ptr>=this.bytes.length&&this.pages_.length>0;)this.ptr-=this.bytes.length,this.bytes=this.pages_.shift()}peekNumber(t){const e=parseInt(t,10);if(t!==e||e<0)throw"Error!  Called peekNumber() with a non-positive integer";if(0===e)return 0;if(t>4)throw"Error!  Called peekNumber("+t+") but this method can only reliably read numbers up to 4 bytes long";if(this.getNumBytesLeft()<e)throw"Error!  Overflowed the byte stream while peekNumber()! n="+e+", ptr="+this.ptr+", bytes.length="+this.getNumBytesLeft();let r=0,s=this.bytes,i=0,a=this.ptr;for(let t=0;t<e;++t)r|=s[a++]<<8*t,a>=s.length&&(s=this.pages_[i++],a=0);return r}readNumber(t){const e=this.peekNumber(t);return this.movePointer_(t),e}peekSignedNumber(t){let e=this.peekNumber(t);const r=Math.pow(2,8*t-1);return e>=r&&(e-=2*r),e}readSignedNumber(t){const e=this.peekSignedNumber(t);return this.movePointer_(t),e}peekBytes(t,e){const r=parseInt(t,10);if(t!==r||r<0)throw"Error!  Called peekBytes() with a non-positive integer";if(0===r)return new Uint8Array;if(r>this.getNumBytesLeft())throw"Error!  Overflowed the byte stream during peekBytes! n="+r+", ptr="+this.ptr+", bytes.length="+this.getNumBytesLeft();const s=new Uint8Array(r);let i=this.bytes,a=this.ptr,n=r,o=0;for(;n>0;){const t=i.length-a,e=Math.min(n,t);s.set(i.subarray(a,a+e),r-n),a+=e,a>=i.length&&(i=this.pages_[o++],a=0),n-=e}return e&&this.movePointer_(r),s}readBytes(t){return this.peekBytes(t,!0)}peekString(t){const e=parseInt(t,10);if(t!==e||e<0)throw"Error!  Called peekString() with a non-positive integer";if(0===e)return"";if(e>this.getNumBytesLeft())throw"Error!  Overflowed the byte stream while peekString()! n="+e+", ptr="+this.ptr+", bytes.length="+this.getNumBytesLeft();let r=new Array(e),s=this.bytes,i=0,a=this.ptr;for(let t=0;t<e;++t)r[t]=String.fromCharCode(s[a++]),a>=s.length&&(s=this.pages_[i++],a=0);return r.join("")}readString(t){const e=this.peekString(t);return this.movePointer_(t),e}push(t){if(!(t instanceof ArrayBuffer))throw"Error! ByteStream.push() called with an invalid ArrayBuffer object";this.pages_.push(new Uint8Array(t)),this.movePointer_(0)}tee(){const t=new a(this.bytes.buffer);return t.bytes=this.bytes,t.ptr=this.ptr,t.pages_=this.pages_.slice(),t.bytesRead_=this.bytesRead_,t}}var n=a;var o=class{constructor(t){if("number"!=typeof t||t<=0)throw"Error! ByteBuffer initialized with '"+t+"'";this.data=new Uint8Array(t),this.ptr=0}insertByte(t){this.data[this.ptr++]=t}insertBytes(t){this.data.set(t,this.ptr),this.ptr+=t.length}writeNumber(t,e){if(e<1||!e)throw"Trying to write into too few bytes: "+e;if(t<0)throw"Trying to write a negative number ("+t+") as an unsigned number to an ArrayBuffer";if(t>Math.pow(2,8*e)-1)throw"Trying to write "+t+" into only "+e+" bytes";const r=[];for(;e-- >0;){const e=255&t;r.push(e),t>>=8}this.insertBytes(r)}writeSignedNumber(t,e){if(e<1)throw"Trying to write into too few bytes: "+e;const r=Math.pow(2,8*e-1);if(t>=r||t<-r)throw"Trying to write "+t+" into only "+e+" bytes";const s=[];for(;e-- >0;){const e=255&t;s.push(e),t>>=8}this.insertBytes(s)}writeASCIIString(t){for(let e=0;e<t.length;++e){const r=t.charCodeAt(e);if(r<0||r>255)throw"Trying to write a non-ASCII string!";this.insertByte(r)}}};const l=new Array(256).fill(0);function h(t){return t<0?t+=4294967296:t}function d(t){return t>=2147483648?t-=4294967296:t}function c(t){return t>=128?t-=256:t}function f(t,e){0==l[1]&&function(){for(let t=0;t<256;++t){let e=t;for(let t=0;t<8;++t)e=(1&e?e>>>1^3988292384:e>>>1)>>>0;l[t]=e}}();for(let r=0;r<e.length;++r){const s=(t^e[r])>>>0&255;t=(l[s]^t>>>8)>>>0}return t}const u={VM_MOV:0,VM_CMP:1,VM_ADD:2,VM_SUB:3,VM_JZ:4,VM_JNZ:5,VM_INC:6,VM_DEC:7,VM_JMP:8,VM_XOR:9,VM_AND:10,VM_OR:11,VM_TEST:12,VM_JS:13,VM_JNS:14,VM_JB:15,VM_JBE:16,VM_JA:17,VM_JAE:18,VM_PUSH:19,VM_POP:20,VM_CALL:21,VM_RET:22,VM_NOT:23,VM_SHL:24,VM_SHR:25,VM_SAR:26,VM_NEG:27,VM_PUSHA:28,VM_POPA:29,VM_PUSHF:30,VM_POPF:31,VM_MOVZX:32,VM_MOVSX:33,VM_XCHG:34,VM_MUL:35,VM_DIV:36,VM_ADC:37,VM_SBB:38,VM_PRINT:39,VM_STANDARD:40},p={VMSF_NONE:0,VMSF_E8:1,VMSF_E8E9:2,VMSF_ITANIUM:3,VMSF_RGB:4,VMSF_AUDIO:5,VMSF_DELTA:6,VMSF_UPCASE:7},y={VM_FC:1,VM_FZ:2,VM_FS:2147483648},g={VM_OPREG:0,VM_OPINT:1,VM_OPREGMEM:2,VM_OPNONE:3};function _(t,e){let r="Unknown.";return t===u?r="VM_Commands.":t===p?r="VM_StandardFilters.":(t===y||t===g)&&(r="VM_OpType."),r+function(t,e){for(let r in t)if(t[r]===e)return r;return null}(t,e)}class b{constructor(){this.Type,this.Data=0,this.Base=0,this.Addr=null}toString(){return null===this.Type?"Error: Type was null in VM_PreparedOperand":"{ Type: "+_(g,this.Type)+", Data: "+this.Data+", Base: "+this.Base+" }"}}class M{constructor(){this.OpCode,this.ByteMode=!1,this.Op1=new b,this.Op2=new b}toString(t){return null===this.OpCode?"Error: OpCode was null in VM_PreparedCommand":(t=t||"")+"{\n"+t+"  OpCode: "+_(u,this.OpCode)+",\n"+t+"  ByteMode: "+this.ByteMode+",\n"+t+"  Op1: "+this.Op1.toString()+",\n"+t+"  Op2: "+this.Op2.toString()+",\n"+t+"}"}}const B=[6,70,70,70,41,41,69,69,9,70,70,70,70,41,41,41,41,41,41,1,1,17,16,5,70,70,70,69,0,0,32,64,2,2,6,6,6,102,102,0];class m{constructor(t,e,r){this.Length=t,this.CRC=e,this.Type=r}}const D=[new m(53,2908186759,p.VMSF_E8),new m(57,1020781950,p.VMSF_E8E9),new m(120,929663295,p.VMSF_ITANIUM),new m(29,235276157,p.VMSF_DELTA),new m(149,472669640,p.VMSF_RGB),new m(216,3162892033,p.VMSF_AUDIO),new m(40,1186579808,p.VMSF_UPCASE)];class A{constructor(){this.mem_=null,this.R_=new Uint32Array(8),this.flags_=0}init(){this.mem_||(this.mem_=new Uint8Array(262144))}isStandardFilter(t){const e=(4294967295^f(4294967295,t,t.length))>>>0;for(let r=0;r<D.length;++r)if(D[r].CRC==e&&D[r].Length==t.length)return D[r].Type;return p.VMSF_NONE}decodeArg(t,e,r){const s=r.peekBits(16);32768&s?(t.Type=g.VM_OPREG,r.readBits(1),t.Data=r.readBits(3),t.Addr=[this.R_[t.Data]]):0==(49152&s)?(t.Type=g.VM_OPINT,r.readBits(2),t.Data=e?r.readBits(8):A.readData(r)):(t.Type=g.VM_OPREGMEM,0==(8192&s)?(r.readBits(3),t.Data=r.readBits(3),t.Addr=[this.R_[t.Data]],t.Base=0):(r.readBits(4),0==(4096&s)?(t.Data=r.readBits(3),t.Addr=[this.R_[t.Data]]):t.Data=0,t.Base=A.readData(r)))}execute(t){this.R_.set(t.InitR);const e=Math.min(t.GlobalData.length,8192);e&&this.mem_.set(t.GlobalData.subarray(0,e),245760);const r=Math.min(t.StaticData.length,8192-e);r&&this.mem_.set(t.StaticData.subarray(0,r),245760+e),this.R_[7]=262144,this.flags_=0;const s=t.AltCmd?t.AltCmd:t.Cmd;t.Cmd.length>0&&!this.executeCode(s)&&(preparedCode.OpCode=u.VM_RET);const i=new DataView(this.mem_.buffer,245760);let a=262143&i.getUint32(32,!0);const n=262143&i.getUint32(28,!0);a+n>=262144&&(a=n=0),t.FilteredData=this.mem_.subarray(a,a+n),t.GlobalData=new Uint8Array(0);const o=Math.min(i.getUint32(48),8128);if(0!=o){const e=o+64;t.GlobalData=new Uint8Array(e),t.GlobalData.set(mem.subarray(245760,245760+e))}}executeCode(t){let e=0,r=t[e];for(;;){switch(r.OpCode){case u.VM_RET:if(this.R_[7]>=262144)return!0;this.R_[7]+=4;continue;case u.VM_STANDARD:this.executeStandardFilter(r.Op1.Data);break;default:console.error("RarVM OpCode not supported: "+_(u,r.OpCode))}e++,r=t[e]}}executeStandardFilter(t){switch(t){case p.VMSF_RGB:{const t=this.R_[4],e=this.R_[0]-3,r=this.R_[1],s=3;let i=0,a=t;if(new DataView(this.mem_.buffer,245760).setUint32(32,t,!0),t>=122880||r<0)break;for(let r=0;r<s;++r){let n=0;for(let o=r;o<t;o+=s){let t;const r=o-e;if(r>=3){const e=this.mem_[a+r],s=this.mem_[a+r-3];t=n+e-s;const i=Math.abs(t-n),o=Math.abs(t-e),l=Math.abs(t-s);t=i<=o&&i<=l?n:o<=l?e:s}else t=n;n=t-this.mem_[i++]&255,this.mem_[a+o]=n}}for(let e=r,s=t-2;e<s;e+=3){const t=this.mem_[a+e+1];this.mem_[a+e]+=t,this.mem_[a+e+2]+=t}break}case p.VMSF_AUDIO:{const t=this.R_[4],s=this.R_[0];let i=0,a=t;if(new DataView(this.mem_.buffer,245760).setUint32(32,t,!0),t>=122880)break;for(let n=0;n<s;++n){let o,l=0,f=0,u=[0,0,0,0,0,0,0],p=0,y=0,g=0,_=0,b=0;for(var e=n,r=0;e<t;e+=s,++r){o=y,y=d(f-p),p=d(f);let t=h(8*l+g*p+_*y+b*o);t=t>>>3&255;let s=this.mem_[i++];t=h(t-s),this.mem_[a+e]=255&t,f=h(c(t-l&255)),l=t;let n=c(s)<<3;if(u[0]+=Math.abs(n),u[1]+=Math.abs(n-p),u[2]+=Math.abs(n+p),u[3]+=Math.abs(n-y),u[4]+=Math.abs(n+y),u[5]+=Math.abs(n-o),u[6]+=Math.abs(n+o),0==(31&r)){let t=u[0],e=0;u[0]=0;for(let r=1;r<7;++r)u[r]<t&&(t=u[r],e=r),u[r]=0;switch(e){case 1:g>=-16&&g--;break;case 2:g<16&&g++;break;case 3:_>=-16&&_--;break;case 4:_<16&&_++;break;case 5:b>=-16&&b--;break;case 6:b<16&&b++}}}}break}case p.VMSF_DELTA:{const t=this.R_[4],e=this.R_[0];let r=0;const s=2*t;if(new DataView(this.mem_.buffer,245760).setUint32(32,t,!0),t>=122880)break;for(let i=0;i<e;++i){let a=0;for(let n=t+i;n<s;n+=e)a=a-this.mem_[r++]&255,this.mem_[n]=a}break}default:console.error("RarVM Standard Filter not supported: "+_(p,t))}}prepare(t,e){let r=t.length;const s=new bitjs.io.BitStream(t.buffer,!0);let i=0;for(let e=1;e<r;++e)i^=t[e];if(s.readBits(8),e.Cmd=[],i==t[0]){const i=this.isStandardFilter(t);if(i!=p.VMSF_NONE){const t=new M;e.Cmd.push(t),t.OpCode=u.VM_STANDARD,t.Op1.Data=i,t.Op1.Addr=[t.Op1.Data],t.Op2.Addr=[null],t.Op1.Type=g.VM_OPNONE,t.Op2.Type=g.VM_OPNONE,r=0}if(32768&s.readBits(1)){const t=A.readData(s)+1;for(let i=0;i<s.bytePtr<r&&i<t;++i){const t=new Uint8Array(e.StaticData.length+1);t.set(e.StaticData),t[t.length-1]=s.readBits(8),e.StaticData=t}}for(;s.bytePtr<r;){const t=new M;e.Cmd.push(t);const r=s.peekBits(1);t.OpCode=r?s.readBits(6)-24:s.readBits(4),4&B[t.OpCode]?t.ByteMode=0!=s.readBits(1):t.ByteMode=0,t.Op1.Type=g.VM_OPNONE,t.Op2.Type=g.VM_OPNONE;const i=3&B[t.OpCode];if(t.Op1.Addr=null,t.Op2.Addr=null,i>0)if(this.decodeArg(t.Op1,t.ByteMode,s),2==i)this.decodeArg(t.Op2,t.ByteMode,s);else if(t.Op1.Type==g.VM_OPINT&&24&B[t.OpCode]){let r=t.Op1.Data;r>=256?r-=256:(r>=136?r-=264:r>=16?r-=8:r>=8&&(r-=16),r+=e.Cmd.length),t.Op1.Data=r}}}const a=new M;e.Cmd.push(a),a.OpCode=u.VM_RET,a.Op1.Addr=[a.Op1.Data],a.Op2.Addr=[a.Op2.Data],a.Op1.Type=g.VM_OPNONE,a.Op2.Type=g.VM_OPNONE;for(let t=0;t<e.Cmd.length;++t){const r=e.Cmd[t];null==r.Op1.Addr&&(r.Op1.Addr=[r.Op1.Data]),null==r.Op2.Addr&&(r.Op2.Addr=[r.Op2.Data])}}setLowEndianValue(t,e,r){const s=r||0;t[s]=255&e,t[s+1]=e>>>8&255,t[s+2]=e>>>16&255,t[s+3]=e>>>24&255}setMemory(t,e,r){if(t<262144){const s=Math.min(r,262144-t);for(let r=0;r<s;++r)this.mem_[t+r]=e[r]}}static readData(t){switch(t.readBits(2)){case 0:return t.readBits(4);case 1:return 0==t.peekBits(4)?(t.readBits(4),(4294967040|t.readBits(8))>>>0):t.readBits(8);case 2:const e=t.getBits();return t.readBits(16),e;default:return t.readBits(16)<<16|t.readBits(16)}}}const S=0,w=1,V=2,E=3;let O=S,P=null,L=null,N=!1,I="",k=0,R=0,C=0,T=0,F=0;const G=function(t){postMessage({type:"info",msg:t})},U=function(){postMessage({type:"progress",currentFilename:I,currentFileNumber:k,currentBytesUnarchivedInFile:R,currentBytesUnarchived:C,totalUncompressedBytesInArchive:T,totalFilesInArchive:F,totalCompressedBytesRead:P.getNumBytesRead()})},v="0123456789ABCDEF";class H{constructor(t){let e=0;this.crc=t.readNumber(2),this.headType=t.readNumber(1),this.flags={},this.flags.value=t.readNumber(2);const r=this.flags.value;switch(this.headType){case 115:this.flags.MHD_VOLUME=!!(1&r),this.flags.MHD_COMMENT=!!(2&r),this.flags.MHD_LOCK=!!(4&r),this.flags.MHD_SOLID=!!(8&r),this.flags.MHD_PACK_COMMENT=!!(16&r),this.flags.MHD_NEWNUMBERING=this.flags.MHD_PACK_COMMENT,this.flags.MHD_AV=!!(32&r),this.flags.MHD_PROTECT=!!(64&r),this.flags.MHD_PASSWORD=!!(128&r),this.flags.MHD_FIRSTVOLUME=!!(256&r),this.flags.MHD_ENCRYPTVER=!!(512&r);break;case 116:this.flags.LHD_SPLIT_BEFORE=!!(1&r),this.flags.LHD_SPLIT_AFTER=!!(2&r),this.flags.LHD_PASSWORD=!!(4&r),this.flags.LHD_COMMENT=!!(8&r),this.flags.LHD_SOLID=!!(16&r),this.flags.LHD_LARGE=!!(256&r),this.flags.LHD_UNICODE=!!(512&r),this.flags.LHD_SALT=!!(1024&r),this.flags.LHD_VERSION=!!(2048&r),this.flags.LHD_EXTTIME=!!(4096&r),this.flags.LHD_EXTFLAGS=!!(8192&r)}switch(this.headSize=t.readNumber(2),e+=7,this.headType){case 115:this.highPosAv=t.readNumber(2),this.posAv=t.readNumber(4),e+=6,this.flags.MHD_ENCRYPTVER&&(this.encryptVer=t.readNumber(1),e+=1);break;case 116:this.packSize=t.readNumber(4),this.unpackedSize=t.readNumber(4),this.hostOS=t.readNumber(1),this.fileCRC=t.readNumber(4),this.fileTime=t.readNumber(4),this.unpVer=t.readNumber(1),this.method=t.readNumber(1),this.nameSize=t.readNumber(2),this.fileAttr=t.readNumber(4),e+=25,this.flags.LHD_LARGE?(this.HighPackSize=t.readNumber(4),this.HighUnpSize=t.readNumber(4),e+=8):(this.HighPackSize=0,this.HighUnpSize=0,4294967295==this.unpackedSize&&(this.HighUnpSize=2147483647,this.unpackedSize=4294967295)),this.fullPackSize=0,this.fullUnpackSize=0,this.fullPackSize|=this.HighPackSize,this.fullPackSize<<=32,this.fullPackSize|=this.packSize,this.filename=t.readBytes(this.nameSize),e+=this.nameSize;let r="";for(let t=0;t<this.filename.length;t++)r+=String.fromCharCode(this.filename[t]);if(this.filename=r,this.flags.LHD_SALT&&(this.salt=t.readBytes(8),e+=8),this.flags.LHD_EXTTIME){const r=t.readNumber(2);e+=2;for(let s=0;s<4;++s){const i=r>>4*(3-s);if(0==(8&i))continue;0!=s&&(t.readBytes(2),e+=2);const a=3&i;for(let r=0;r<a;++r)t.readNumber(1),e+=1}}this.flags.LHD_COMMENT,e<this.headSize&&t.readBytes(this.headSize-e);break;case 123:break;default:N&&G("Found a header of type 0x"+(s=this.headType,v[s>>4]+v[15&s])),t.readBytes(this.headSize-7)}var s}dump(){var t;G("  crc="+this.crc),G("  headType="+this.headType),G("  flags="+(t=this.flags.value,v[t>>12&15]+v[t>>8&15]+v[t>>4&15]+v[15&t])),G("  headSize="+this.headSize),116==this.headType&&G("Found FILE_HEAD with packSize="+this.packSize+", unpackedSize= "+this.unpackedSize+", hostOS="+this.hostOS+", unpVer="+this.unpVer+", method="+this.method+", filename="+this.filename)}}const z=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224],X=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5],Z=[4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,14,0,12],x=[0,4,8,16,32,64,128,192],W=[2,2,3,4,5,6,6,6],j=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576,32768,49152,65536,98304,131072,196608,262144,327680,393216,458752,524288,589824,655360,720896,786432,851968,917504,983040],K=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16],J=new Array(404),Y={DecodeLen:new Array(16),DecodePos:new Array(16),DecodeNum:new Array(20)},q={DecodeLen:new Array(16),DecodePos:new Array(16),DecodeNum:new Array(299)},Q={DecodeLen:new Array(16),DecodePos:new Array(16),DecodeNum:new Array(60)},$={DecodeLen:new Array(16),DecodePos:new Array(16),DecodeNum:new Array(17)},tt={DecodeLen:new Array(16),DecodePos:new Array(16),DecodeNum:new Array(28)},et=[];let rt,st;function it(t){const e=new Array(20),r=new Array(404);if(t.readBits(8-t.bitPtr&7),t.readBits(1))return void G("Error!  PPM not implemented yet");if(!t.readBits(1))for(let t=J.length;t--;)J[t]=0;for(let r=0;r<20;++r){const s=t.readBits(4);if(15==s){let s=t.readBits(4);if(0==s)e[r]=15;else{for(s+=2;s-- >0&&r<20;)e[r++]=0;--r}}else e[r]=s}nt(e,0,Y,20);for(let e=0;e<404;){const s=at(t,Y);if(s<16)r[e]=s+J[e]&15,e++;else if(s<18){let i=16==s?t.readBits(3)+3:t.readBits(7)+11;for(;i-- >0&&e<404;)r[e]=r[e-1],e++}else{let i=18==s?t.readBits(3)+3:t.readBits(7)+11;for(;i-- >0&&e<404;)r[e++]=0}}nt(r,0,q,299),nt(r,299,Q,60),nt(r,359,$,17),nt(r,376,tt,28);for(let t=J.length;t--;)J[t]=r[t];return!0}function at(t,e){const r=e.DecodeLen,s=e.DecodePos,i=e.DecodeNum,a=65534&t.getBits(),n=a<r[8]?a<r[4]?a<r[2]?a<r[1]?1:2:a<r[3]?3:4:a<r[6]?a<r[5]?5:6:a<r[7]?7:8:a<r[12]?a<r[10]?a<r[9]?9:10:a<r[11]?11:12:a<r[14]?a<r[13]?13:14:15;return t.readBits(n),i[s[n]+(a-r[n-1]>>>16-n)]}function nt(t,e,r,s){const i=r.DecodeLen,a=r.DecodePos,n=r.DecodeNum,o=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],l=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];let h=0,d=0;for(let t=n.length;t--;)n[t]=0;for(let r=0;r<s;r++)o[15&t[r+e]]++;o[0]=0,l[0]=0,a[0]=0,i[0]=0;for(let t=1;t<16;++t)h=2*(h+o[t]),d=h<<15-t,d>65535&&(d=65535),i[t]=d,a[t]=a[t-1]+o[t-1],l[t]=a[t];for(let r=0;r<s;++r)0!=t[r+e]&&(n[l[15&t[e+r]]++]=r)}function ot(){const t=rt.ptr-R;R=rt.ptr,C+=t,U()}const lt=new Array(1028);function ht(t){const e=new Array(19),r=new Array(1028);let s,i,a;t.readBits(1);if(!t.readBits(1))for(let t=lt.length;t--;)lt[t]=0;for(s=374,a=0;a<19;a++)e[a]=t.readBits(4);for(nt(e,0,Y,19),a=0;a<374;){const e=at(t,Y);if(e<16)r[a]=e+lt[a]&15,a++;else if(16==e)for(i=t.readBits(2)+3;i-- >0&&a<374;)r[a]=r[a-1],a++;else for(i=17==e?t.readBits(3)+3:t.readBits(7)+11;i-- >0&&a<374;)r[a++]=0}nt(r,0,q,298),nt(r,298,Q,48),nt(r,346,tt,28);for(let t=lt.length;t--;)lt[t]=r[t]}let dt,ct,ft=0,ut=0,pt=[0,0,0,0];const yt=new A;let gt=[],_t=[],bt=[],Mt=0;function Bt(t,e){yt.init();const r=new i(e.buffer,!0);let s;if(128&t?(s=A.readData(r),0==s?(bt=[],Mt=0,gt=[],_t=[]):s--):s=Mt,s>gt.length||s>bt.length)return!1;Mt=s;const a=s==gt.length,n=new UnpackFilter;let o=null;if(a){if(s>1024)return!1;o=new UnpackFilter,gt.push(o),n.ParentFilter=gt.length-1,bt.push(0),o.ExecCount=0}else o=gt[s],n.ParentFilter=s,o.ExecCount++;let l=0;for(let t=0;t<_t.length;++t)_t[t-l]=_t[t],null==_t[t]&&l++,l>0&&(_t[t]=null);0==l&&(_t.push(null),l=1);const h=_t.length-l;_t[h]=n,n.ExecCount=o.ExecCount;let d=A.readData(r);64&t&&(d+=258),n.BlockStart=d+rt.ptr&MAXWINMASK,n.BlockLength=32&t?A.readData(r):s<bt.length?bt[s]:0,n.NextWindow=st.ptr!=rt.ptr&&(st.ptr-rt.ptr&MAXWINMASK)<=d,bt[s]=n.BlockLength;for(let t=0;t<7;++t)n.Prg.InitR[t]=0;if(n.Prg.InitR[3]=VM_GLOBALMEMADDR,n.Prg.InitR[4]=n.BlockLength,n.Prg.InitR[5]=n.ExecCount,16&t){const t=r.readBits(7);for(let e=0;e<7;++e)t&1<<e&&(n.Prg.InitR[e]=A.readData(r))}if(a){const t=A.readData(r);if(t>=65536||0==t)return!1;const e=new Uint8Array(t);for(let s=0;s<t;++s)e[s]=r.readBits(8);yt.prepare(e,o.Prg)}n.Prg.Cmd=o.Prg.Cmd,n.Prg.AltCmd=o.Prg.Cmd;const c=o.Prg.StaticData.length;if(c>0&&c<VM_GLOBALMEMSIZE)for(let t=0;t<c;++t)n.Prg.StaticData[t]=o.Prg.StaticData[t];n.Prg.GlobalData.length<VM_FIXEDGLOBALSIZE&&(n.Prg.GlobalData=new Uint8Array(VM_FIXEDGLOBALSIZE));const f=n.Prg.GlobalData;for(let t=0;t<7;++t)yt.setLowEndianValue(f,n.Prg.InitR[t],4*t);yt.setLowEndianValue(f,n.BlockLength,28),yt.setLowEndianValue(f,0,32),yt.setLowEndianValue(f,n.ExecCount,44);for(let t=0;t<16;++t)f[48+t]=0;if(8&t){const t=A.readData(r);if(t>VM_GLOBALMEMSIZE-VM_FIXEDGLOBALSIZE)return!1;const e=n.Prg.GlobalData.length;if(e<t+VM_FIXEDGLOBALSIZE){const r=t+VM_FIXEDGLOBALSIZE-e,s=new Uint8Array(f.length+r);s.set(f),n.Prg.GlobalData=s,f=s}for(let e=0;e<t;++e)f[VM_FIXEDGLOBALSIZE+e]=r.readBits(8)}return!0}function mt(t){const e=t.readBits(8);let r=1+(7&e);7==r?r=t.readBits(8)+7:8==r&&(r=t.readBits(16));const s=new Uint8Array(r);for(let e=0;e<r;e++)s[e]=t.readBits(8);return Bt(e,s)}function Dt(t,e){const r=new Array(60),s=new Array(60);let i,a=0,n=0,o=0;for(let t=0;t<Z.length;t++,n++)for(let e=0;e<Z[t];e++,o++,a+=1<<n)r[o]=a,s[o]=n;pt=[0,0,0,0],dt=0,ct=0;for(let t=J.length;t--;)J[t]=0;for(it(t);;){let e=at(t,q);if(e<256)rt.insertByte(e);else if(e>=271){let a=z[e-=271]+3;(i=X[e])>0&&(a+=t.readBits(i));const n=at(t,Q);let o=r[n]+1;if((i=s[n])>0)if(n>9)if(i>4&&(o+=t.getBits()>>>20-i<<4,t.readBits(i-4)),ft>0)ft--,o+=ut;else{const e=at(t,$);16==e?(ft=15,o+=ut):(o+=e,ut=e)}else o+=t.readBits(i);o>=8192&&(a++,o>=262144&&a++),Et(o),Vt(a,o),Ot(a,o)}else if(256!=e){if(257!=e)if(258!=e)if(e<263){const r=e-259,s=pt[r];for(let t=r;t>0;t--)pt[t]=pt[t-1];pt[0]=s;const a=at(t,tt);let n=z[a]+2;(i=X[a])>0&&(n+=t.readBits(i)),Vt(n,s),Ot(n,s)}else if(e<272){let r=x[e-=263]+1;(i=W[e])>0&&(r+=t.readBits(i)),Et(r),Vt(2,r),Ot(2,r)}else;else 0!=ct&&Ot(ct,dt);else if(!mt(t))break}else if(!wt(t))break}ot(),function(){let t=rt.ptr&MAXWINMASK;for(let e=0;e<_t.length;++e){const r=_t[e];if(null==r)continue;if(r.NextWindow){r.NextWindow=!1;continue}const s=r.BlockStart,i=r.BlockLength;if((s-st.ptr&MAXWINMASK)<t){if(st.ptr!=s&&(At(st.ptr,s),t=rt.ptr-st.ptr&MAXWINMASK),!(i<=t)){for(let t=e;t<_t.length;++t){const e=_t[t];null!=e&&e.NextWindow&&(e.NextWindow=!1)}return}{const a=s+i&MAXWINMASK;if(s<a||0==a)yt.setMemory(0,rt.data.subarray(s,s+i),i);else{const t=MAXWINSIZE-s;yt.setMemory(0,rt.data.subarray(s,s+t),t),yt.setMemory(t,rt.data,a)}const n=gt[r.ParentFilter].Prg,o=r.Prg;if(n.GlobalData.length>VM_FIXEDGLOBALSIZE&&(o.GlobalData=new Uint8Array(n.GlobalData)),St(o),o.GlobalData.length>VM_FIXEDGLOBALSIZE){const t=o.GlobalData.length;n.GlobalData.length<t&&(n.GlobalData=new Uint8Array(t)),n.GlobalData.set(this.mem_.subarray(VM_FIXEDGLOBALSIZE,VM_FIXEDGLOBALSIZE+t),VM_FIXEDGLOBALSIZE)}else n.GlobalData=new Uint8Array(0);let l=o.FilteredData;for(_t[e]=null;e+1<_t.length;){const t=_t[e+1];if(null==t||t.BlockStart!=s||t.BlockLength!=l.length||t.NextWindow)break;yt.setMemory(0,l,l.length);const r=gt[t.ParentFilter].Prg,i=t.Prg,a=r.GlobalData.length;if(a>VM_FIXEDGLOBALSIZE&&(i.GlobalData=new Uint8Array(a),i.GlobalData.set(r.GlobalData.subarray(VM_FIXEDGLOBALSIZE,VM_FIXEDGLOBALSIZE+a),VM_FIXEDGLOBALSIZE)),St(i),i.GlobalData.length>VM_GLOBALMEMSIZE){const t=i.GlobalData.length;r.GlobalData.length<t&&(r.GlobalData=new Uint8Array(t)),r.GlobalData.set(this.mem_.subarray(VM_FIXEDGLOBALSIZE,VM_FIXEDGLOBALSIZE+t),VM_FIXEDGLOBALSIZE)}else r.GlobalData=new Uint8Array(0);l=i.FilteredData,e++,_t[e]=null}for(let t=0;t<l.length;++t)st.insertByte(l[t]);t=rt.ptr-st.ptr&MAXWINMASK}}}At(st.ptr,rt.ptr),rt=st}()}function At(t,e){e<t?console.error("endPtr < startPtr, endPtr="+e+", startPtr="+t):t<e&&function(t,e){if(st.ptr>=rt.data.length)return;const r=rt.data.length-st.ptr;e>r&&(e=r);for(let r=0;r<e;++r)st.insertByte(rt.data[t+r])}(t,e-t)}function St(t){if(t.GlobalData.length>0){const e=st.ptr;t.InitR[6]=e,yt.setLowEndianValue(t.GlobalData,e,36),yt.setLowEndianValue(t.GlobalData,e>>>32>>0,40),yt.execute(t)}}function wt(t){ot();let e=!1,r=!1;return t.readBits(1)?e=!0:(r=!0,e=!!t.readBits(1)),!(r||e&&!it(t))}function Vt(t,e){dt=e,ct=t}function Et(t){pt.splice(3,1),pt.splice(0,0,t)}function Ot(t,e){let r=rt.ptr-e;if(r<0){let e=et.length;for(;r<0;)r=et[--e].data.length+r;for(;t--;)rt.insertByte(et[e].data[r++])}if(t>e)for(;t--;)rt.insertByte(rt.data[r++]);else rt.insertBytes(rt.data.subarray(r,r+t))}function Pt(t){const e=t.header.unpVer<=15?15:t.header.unpVer,r=t.header.flags.LHD_SOLID,s=new i(t.fileData.buffer,!0,t.fileData.byteOffset,t.fileData.byteLength);switch(rt=new o(t.header.unpackedSize),N&&G("Unpacking "+t.filename+" RAR v"+e),e){case 15:G("ERROR!  RAR 1.5 compression not supported");break;case 20:case 26:!function(t,e){const r=rt.data.length;let s=0;for(e||ht(t);r>rt.ptr;){let e=at(t,q);if(e<256)rt.insertByte(e);else if(e>269){let r=z[e-=270]+3;(Bits=X[e])>0&&(r+=t.readBits(Bits));let i=at(t,Q),a=j[i]+1;(Bits=K[i])>0&&(a+=t.readBits(Bits)),a>=8192&&(r++,a>=262144&&r++),ct=r,dt=pt[3&s++]=a,Ot(r,a)}else if(269!=e)if(256!=e)if(e<261){const r=pt[s-(e-256)&3],i=at(t,tt);let a=z[i]+2;(Bits=X[i])>0&&(a+=t.readBits(Bits)),r>=257&&(a++,r>=8192&&(a++,r>=262144&&a++)),ct=a,dt=pt[3&s++]=r,Ot(a,r)}else if(e<270){let r=x[e-=261]+1;(Bits=W[e])>0&&(r+=t.readBits(Bits)),ct=2,dt=pt[3&s++]=r,Ot(2,r)}else;else dt=pt[3&s++]=dt,Ot(ct,dt);else ht(t),ot()}ot()}(s,r);break;case 29:case 36:st=new o(rt.data.length),Dt(s)}return et.push(rt),rt.data}class Lt{constructor(t){this.header=new H(t),this.filename=this.header.filename,116!=this.header.headType&&123!=this.header.headType?(this.isValid=!1,G("Error! RAR Volume did not include a FILE_HEAD header ")):(this.fileData=null,this.header.packSize>0&&(this.fileData=t.readBytes(this.header.packSize),this.isValid=!0))}unrar(){if(!this.header.flags.LHD_SPLIT_BEFORE)if(48==this.header.method){N&&G("Unstore "+this.filename),this.isValid=!0,R+=this.fileData.length,C+=this.fileData.length;const t=this.header.packSize,e=new o(t);e.insertBytes(this.fileData),this.fileData=e.data}else this.isValid=!0,this.fileData=Pt(this)}}onmessage=function(t){const e=t.data.file||t.data.bytes;if(N=!!t.data.logToConsole,P?P.push(e):(P=new n(e),I="",k=0,R=0,C=0,T=0,F=0,L=[],postMessage({type:"start"})),O===S)try{!function(){let t=P.tee();const e=new H(t);if(24914==e.crc&&114==e.headType&&6689==e.flags.value&&7==e.headSize){N&&G("Found RAR signature"),115!=new H(t).headType?G("Error! RAR did not include a MAIN_HEAD header"):P=t.tee()}}(),O=w}catch(t){if("string"!=typeof t||!t.startsWith("Error!  Overflowed"))throw console.error("Found an error while unrarring"),console.dir(t),t;N&&console.dir(t),O=V,U()}if(O===w||O===V)try{!function(){let t=P.tee(),e=null;do{e=new Lt(t),N&&(G("RAR localFile isValid="+e.isValid+", volume packSize="+e.header.packSize),e.header.dump()),e&&e.isValid&&e.header.packSize>0?(P=t.tee(),T+=e.header.unpackedSize,L.push(e),I=e.header.filename,R=0,e.unrar(),e.isValid&&(postMessage({type:"extract",unarchivedFile:e}),U())):0==e.header.packSize&&0==e.header.unpackedSize&&(e.isValid=!0)}while(e.isValid&&t.getNumBytesLeft()>0);F=L.length,U(),P=t.tee()}(),O=E,postMessage({type:"finish",metadata:{}})}catch(t){if("string"!=typeof t||!t.startsWith("Error!  Overflowed"))throw console.error("Found an error while unrarring"),console.dir(t),t;N&&console.dir(t),O=V}}}]);
//# sourceMappingURL=bitjs.0.worker.js.map